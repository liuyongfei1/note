## 前文回顾

本文要更加深入的去说一说CMS垃圾回收期间的一些细节问题，同时给出CMS常见的JVM参数应如何设置。

## 1.并发回收垃圾导致CPU资源紧张

CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统工作，但是大家发现没有，在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。

- 并发标记的时候，需要对 GC Roots 进行深度追踪，看所有对象里面到底有多少是存活的。
- 但是因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时比较高。并发清理，又需要把垃圾对象从各种随机的内存位置清理掉，也是比较耗时的。

所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收器线程的数量是：（CPU核数 + 3）/ 4。

我们用最普通的2核4G机器来计算一下，假设是2核CPU，本来CPU资源就有限，结果此时CMS还会有个 （2 + 3）/ 4 = 1 个垃圾回收线程，去占用宝贵的一个CPU。

所以其实CMS这个并发垃圾回收的机制，第一个问题就是会耗CPU资源。

## 2. Corcurrent Mode Failure问题 

这个问题是很多同学都很关注的一个问题，就是如下图：

在并发清理阶段，CMS 只不过是回收之前标记好的垃圾对象。

但是这个阶段系统一直在运行，可能会随着系统运行，让一些对象进入老年代，然后短时间内又没人引用这些对象了，就变成垃圾对象，这种垃圾对象就是老年代的"浮动垃圾"。

因为他虽然成为了垃圾，但是CMS只能回收之前标记出来的垃圾对象，不会回收他们，需要等到下一场GC的时候才能回收他们。

所以为了保证在CMS垃圾回收期间，还有一定的内存空间让一些对象进入老年代，一般会预留一些空间。

CMS 垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就会自动执行 GC。

