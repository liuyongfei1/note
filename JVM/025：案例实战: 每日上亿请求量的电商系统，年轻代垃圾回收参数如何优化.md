## 1、案例背景引入

我们的案例背景是每日上亿请求量的电商系统，那么大家可以开推算一下每日上亿请求量的电商系统，他会每日有多少活跃用户？

一般按每个用户平均访问 20 次来计算，那么上亿请求量，大致需要有 500万 日活用户。

那么继续来推算一下，这 500万 的日活用户都会进来进行大量的浏览，那么多少人会下订单？

这里可以按照 10% 的付费转化率来计算，每天大概有 50万 人会下订单，那么大致就是每天会有 50万 订单。

这 50万 订单算他集中在每天 4 小时的高峰期内，那么其实平均下来每秒钟大概也就几十个订单，大家是不是觉得根本没啥可说的？

因为几十个订单的压力下，根本就不需要对 JVM 多关注，基本上就是每秒钟占用一些新生代内存，隔很久新生代才会满，然后一次 Minor GC 后垃圾对象清理掉，内存就空出来了，几乎无压力。

## 2、特殊的电商大促场景

但是如果你要是考虑到特殊的电商大促场景，就不会这么想了。

假如在类似 双11 的节日里，零点的时候，很多人在等着大促开始就要剁手购物，这个时候，可能在大促开始的短短 10分钟 内，瞬间就会有 50万 订单。

那么此时，每秒就会有接近 1000 的下单请求，我们就针对这种大促场景来对订单系统的内存使用模型分析一下。

## 3、扛住大促的瞬时压力需要几台机器

那么要扛住大促期间的瞬时下单压力，订单系统需要部署几台机器呢？

基本上可以按 3台 来算，就是每台机器每秒要扛 300 个下单请求。这个也是非常合理的，而且需要假设订单系统部署的就是最普通的标配 4核 8G 机器。

从机器本身的CPU资源和内存资源角度，扛住每秒 300 个下单请求时没问题的。

但是问题在于需要对 JVM 有限的内存资源进行合理的分配和优化，包括对立即回收进行合理的优化，让 JVM 的GC 次数量尽可能最少，而且尽量避免 Full GC，这样可以尽可能减少 JVM 的GC 对高峰期的系统造成的影响。

## 4、大型高峰期订单系统的内存使用模型估算

基本上可以按照每秒钟处理 300个 下单请求来估算，其实无论是订单处理性能还是并发情况，都跟生产很接近。

因为处理下单请求时比较耗时的，涉及很多接口的调用，基本上每秒处理 100~300 个下单请求是差不多的。

- 那么，每个订单咱就按 1kb 的大小来估算，单单是 300个 订单就会有 300kb 的内存开销。

- 然后算上订单对象连带的订单条目对象、库存、促销、优惠券等等一系列的其他业务对象，一般需要对单个对象开销放大 10倍~20倍。
- 此外，除了下单之外，这个订单系统还会有很多订单相关的其他操作，比如查询订单之类的，所以连带算起来，可以往大了估算，再扩大 10倍 的量。

那么，每秒钟会有大概 300kb * 20 * 10 = 60mb 的内存开销。但是一秒过后，可以认为这 60mb 对象就是垃圾了，因为 300个 订单处理完了，所有相关对象都失去了引用，可以回收的状态。

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201161459826.png" alt="image-20210201161459826" style="zoom:50%;" />

## 5、内存到底该如何分配

假如我们有 4核8G 的机器，那么给JVM的内存一般到4G，剩下几个G会留点空余给操作系统之类的来使用，不要想着把机器内存一下子都耗尽，其中堆内存我们可以给 3G，新生代我们可以给到 1.5G，老年代也是 1.5G。

然后每个线程的Java虚拟机栈有1 M，那么JVM里如果有几百个线程大概会有 几百M，然后再给永久代 256M 内存，基本上这 4G 内存就差不多了。

此时 JVM 内存如下图所示：

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201161524875.png" alt="image-20210201161524875" style="zoom:50%;" />

接着就很明确了，订单系统的系统程序在大促期间不停的运行，每秒处理 500个 订单，都会占据新生代 60MB 的内存空间。

但是 1秒 过后这 60MB 对象都会变成垃圾，那么新生代 1.5G 的内存空间大概需要 25秒 就会占满，如下图：

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201161735893.png" alt="image-20210201161735893" style="zoom:50%;" />

25秒 过后，就会要进行 Minor GC了，此时因为有 "-XX HandlePromotionFailure"选项，所以需要进行检查，主要就是比较**"老年代可用空间大小"**和"**历次Minor GC 后进入老年代对象的平均大小"**，刚开始肯定这个检查是可用通过的。

所以Minor GC 直接运行，一下子可用回收掉 99% 的新生代对象，因为除了最近1秒的 订单请求还在处理，大部分订单早就处理完了，所以在此期间存活的对象可能就 100MB 左右。

但是这里问题来了，如果"-XX: SurvivorRatio" 参数默认值为8，那么此时新生代里 Eden区大概占据了 1.2GB 内存，每个 Survivor 区是 150MB 的内存。

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201162425195.png" alt="image-20210201162425195" style="zoom:50%;" />

所以Eden区1.2GB 满了就要进行 Minor GC了，因此大概只需要 20秒，就会把 Eden区占满了，就要进行 Minor GC了。

然后 GC 过后，存活对象在 100MB 左右，会进入 S1区域，然后再运行 20秒，会把 Eden区占满，再次垃圾回收Eden和S1中的对象，存活对象还可能是 100MB 左右 进入 S2区。

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201162721310.png" alt="image-20210201162721310" style="zoom:50%;" />

此时JVM参数如下：

"-Xms3072M -Xmx 3072M -Xmn 1536M -Xss 1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:Survivor=8"

## 6、新生代垃圾回收优化一：Survivor空间不够

首先在进行JVM优化的时候，第一个要考虑的问题，就是你通过估算，你的新生代的Survivor区到底够不够。

按照上述逻辑，首先每次新生代垃圾回收后存活的对象在 100M左右，有可能会突破 150M，那么岂不是经常会出现 GC 过后的对象无法放入 Survivor区？然后岂不是频繁让对象进入老年代？

还有，即使 Minor GC 后的对象少于 150MB，但是即使是 100MB 的对象进入Survivor区，因为这是一批同龄对象，直接超过了Survivor区空间的 50%，此时也可能会导致对象进入老年代。

所以其实按照这个模型来说，Survivor区是明显不够的。

这里其实建议的是调整**新生代和老年代的大小**，因为这种普通业务系统，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，首先得先让对象尽量留在新生代里。

所以此时可以把新生代调为 2G，老年代调为 1G，那么此时 Eden区 为 1.6G，每个 Survivor区为 200MB，如下图：

<img src="025：案例实战: 每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化.assets/image-20210201170203960.png" alt="image-20210201170203960" style="zoom:50%;" />

这个时候，Survivor区变大，就大大降低了新生代 GC过后存活对象在Survivor区里放不下的问题，或者是同龄对象超过Survivor 50%的问题。

这样就大大降低了新生代对象进入老年代的概率。

此时，JVM 的参数如下：

"-Xms3072M -Xmx 3072M -Xmn 2048M -Xss 1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:Survivor=8"

## 7、新生代对象躲过多少次垃圾回收后进入老年代

大家都知道，除了 Minor GC 后 对象无法存入 Survivor区 导致对象进入老年代之外，还有就是有些对象连续躲过 15 次垃圾回收后会自动进入老年代。

此时 JVM参数如下：

"-Xms3072M -Xmx 3072M -Xmn 2048M -Xss 1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:Survivor=8 -XX:MaxTenuring Threshold=5"

## 8、多大的对象直接进入老年代

另外有一个逻辑是说，大对象可以直接进入老年代，因为大对象是说明要长期存活和使用的。

比如在JVM里可能会缓存一些数据，这个一般可以结合自己系统中有没有创建大的对象来决定。

但是一般来说，给个1MB足矣，因为一般很少有超过1MB的大对象。如果有，可能是你提前分配了一个大数组，大List之类的东西用来存放缓存的数据。

此时 JVM参数如下：

"-Xms3072M -Xmx 3072M -Xmn 2048M -Xss 1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:Survivor=8 -XX:MaxTenuring Threshold=5 -XX:XX:PretenureSizeThreshold=1M"

## 9、别忘了指定垃圾回收器

同时大家别忘了要指定垃圾回收器，新生代使用ParNew，老年代使用CMS，如下JVM参数：

"-Xms3072M -Xmx 3072M -Xmn 2048M -Xss 1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:Survivor=8 -XX:MaxTenuring Threshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC"

ParNew 垃圾回收器的核心参数，其实就是配套的新生代大小、Eden区和Survivor区的比例，只要你设置合理，避免Minor GC后对象放不下Survivor区 而进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空间，那么一般Minor GC 就没有什么问题。

然后根据你的系统模型，合理设置"-XX:MaxTenuring Threshold"，让那些长期存活的对象，抓紧尽快进入老年代，别在新生代里一直待着。

这样，基本上一个初步的优化好的JVM参数就结合你的业务出来了。