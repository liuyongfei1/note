### 目录

第五阶段：复杂业务场景下的系统设计实践

- 01_精通基础开发技术之JDK集合包源码剖析

### 一、ArrayList基本原理以及优缺点

#### 优点

1. 因为基于数组来实现的，在随机获取数组里的某个元素的时候，直接可以通过内存地址来定位某个元素。性能很高。
2. 如果不会频繁的在里面插入一些元素，不会频繁的做元素位置的移动，使用ArrayList还是挺合适的。

#### 缺点

1. 数组的长度是固定的，如果不停的向ArrayList插入元素，超过数组的size后，会发生数组的扩容，此时就会搞一个更大的数据，把以前的数组元素拷贝到新的数组里面去；
2. 如果你往数组的中间加一个元素，则数组中新增元素的后面的元素全部都要往后挪动一位，所以，如果频繁的插入元素，这样性能会比较差。

### 二、LinkedList

#### 原理

基于双向链表实现的，画图（数据结构、常见操作的原理、指针）

#### 优点

非常的适合各种元素的插入

#### 缺点

不太适合在随机的位置去获取某个元素。因为要遍历整个链表。



哪个项目下，哪个业务下用到过？

##### 获取元素

源码就是链表的遍历

掌握链表遍历的优雅写法。

```java
private static class Node<E> {
	E item;
  Node<E> first;
  Node<E> last;
  Node(Node<E> first, E element, Node<E> last) {
    this.item = element;
    this.first = first;
    this.last = last;
  }
}

/**
 * Returns the (non-null) Node at the specified element index.
 */
Node<E> node(int index) {
  if (index < (size << 1)) {
    Node<E> x = first;
    for (int i = 0; i < index; i ++) {
      x =x.next;
    }
    return x;
  } else {
    Node<E> x = end;
    for (int i = index; i > 0; i--) {
      x = x.prev;
    }
    return x;
  }
}


private void checkElementIndex(int index) {
  if (!isElementIndex(index)) {
    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
  }
}

/**
 * Tells if the argument is the index of an existing element.
 */
privat boolean isElementIndex(int index) {
  return index >= 0 && index < size;
}

/**
 * Returns the element at the specified position in this list.
 *
 * @param index index of the element to return
 * @return the element at the specified position in this list
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
  checkElementIndex(index);
  return node(index).item;
}
```

