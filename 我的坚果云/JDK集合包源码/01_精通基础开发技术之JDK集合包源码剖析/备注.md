### 目录

第五阶段：复杂业务场景下的系统设计实践

- 01_精通基础开发技术之JDK集合包源码剖析

### 一、ArrayList基本原理以及优缺点

#### 优点

1. 因为基于数组来实现的，在随机获取数组里的某个元素的时候，直接可以通过内存地址来定位某个元素。性能很高。
2. 如果不会频繁的在里面插入一些元素，不会频繁的做元素位置的移动，使用ArrayList还是挺合适的。

#### 缺点

1. 数组的长度是固定的，如果不停的向ArrayList插入元素，超过数组的size后，会发生数组的扩容，此时就会搞一个更大的数据，把以前的数组元素拷贝到新的数组里面去；
2. 如果你往数组的中间加一个元素，则数组中新增元素的后面的元素全部都要往后挪动一位，所以，如果频繁的插入元素，这样性能会比较差。

### 二、LinkedList

#### 原理

基于双向链表实现的，画图（数据结构、常见操作的原理、指针）

#### 优点

非常的适合各种元素的插入

#### 缺点

不太适合在随机的位置去获取某个元素。因为要遍历整个链表。



哪个项目下，哪个业务下用到过？

##### 获取元素

源码就是链表的遍历

掌握链表遍历的优雅写法。

```java
private static class Node<E> {
	E item;
  Node<E> first;
  Node<E> last;
  Node(Node<E> first, E element, Node<E> last) {
    this.item = element;
    this.first = first;
    this.last = last;
  }
}

/**
 * Returns the (non-null) Node at the specified element index.
 */
Node<E> node(int index) {
  if (index < (size << 1)) {
    Node<E> x = first;
    for (int i = 0; i < index; i ++) {
      x =x.next;
    }
    return x;
  } else {
    Node<E> x = end;
    for (int i = index; i > 0; i--) {
      x = x.prev;
    }
    return x;
  }
}


private void checkElementIndex(int index) {
  if (!isElementIndex(index)) {
    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
  }
}

/**
 * Tells if the argument is the index of an existing element.
 */
privat boolean isElementIndex(int index) {
  return index >= 0 && index < size;
}

/**
 * Returns the element at the specified position in this list.
 *
 * @param index index of the element to return
 * @return the element at the specified position in this list
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
  checkElementIndex(index);
  return node(index).item;
}
```

### 三、Vector和Stack

栈，先进后出。

主要就是 push() 和 pop() 这两个方法。

### 四、HashMap

hashmap其实是整个JDK集合包源码剖析的重点。

#### 常见的面试题如下:

- hash冲突的时候怎么解决？

- hashmap的原理，对key进行hash，找到对应的位置，放在里面，查询的时候，也是对key进行hash；

- hashmap的扩容是怎么处理的，扩容的原理；

- jdk1.8以后hashmap的底层做了哪些优化，让你聊聊hashmap底层的源码，源码层面聊聊hashmap的原理；
- 聊聊迭代java集合的时候，fail-fast机制是什么东西？
- 并发包里的东西问的也比较多。

#### 哈希表

要理解hashcode，首先要理解hash表这个概念。

- hash表也叫做散列表（hash table），是根据关键码值（key value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫散列函数，存放记录的数组叫散列表。
- 给定表M，存在函数f(key)，对任意给定的关键字key，带入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(hash)表，函数f(key)为哈希(hash)函数。
- 简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。
- 具有快速查找和插入操作的优点。

#### hashcode

- hashcode通过hash函数计算得到，hashcode就是在hash表中有对应的位置；
- 每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode。

##### 作用

hashcode存在的作用主要是为了查找的快捷性，hashcode是用来在散列存储结构中确定对象的存储地址的。

##### 复杂度o(n)、o(1)

jdk1.8以后，hashmap的数据结构是：数组+链表+红黑树。

链表的遍历性能，时间复杂度是o(n)，红黑树是o(logn)。

二叉查找树

红黑树？=>可以看文章：漫画算法

