技术分享即将结束，再给各位同学来一个彩蛋

【面试题剖析】

[1、相同客户端线程是如何实现可重入加锁的？]

第一次加锁时，会往key对应的hash数据结构中设置 UUID:ThreadId 1，表示当前线程对key加锁一次；

如果相同线程来再次对这个key加锁，只需要将UUID:ThreadId持有锁的次数加1即可，就为：UUID:ThreadId 2 了，Redisson底层就是通过这样的数据结构来表示重入加锁的语义的。


[2、其他线程加锁失败时，底层是如何实现阻塞的？]

线程加锁失败了，如果没有设置获取锁超时时间，此时就会进入一个while的死循环中，一直尝试加锁，直到加锁成功才会返回。

[3、客户端宕机了，锁是如何释放的？]

客户端宕机了，相应的watchdog后台定时任务当然也就没了，此时就无法对key进行定时续期，那么当指定存活时间过后，key就会自动失效，锁当然也就自动释放了。

[4、客户端如何主动释放持有的锁？]

客户端主动释放锁，底层同样也是通过执行lua脚本的方式实现的，如果判断当前释放锁的key存在，并且在key的hash数据结构中、存在当前线程的加锁信息，那么此时就会扣减当前线程对这个key的重入锁次数。

扣减线程的重入锁次数之后，如果当前线程在这个key中的重入锁次数为0，此时就会直接释放锁，如果当前线程在这个key中的重入锁次数依然还大于0，此时就直接重置一下key的存活时间为30s。


[5、客户端尝试获取锁超时的机制在底层是如何实现的？]

如果在加锁时就指定了尝试获取锁超时的时间，如果获取锁失败，此时就不会无止境的在while死循环中一直获取锁，而是根据你指定的获取锁超时时间，在这段时间范围内，要是获取不到锁，就会标记为获取锁失败，然后直接返回false。


[6、客户端锁超时自动释放机制在底层又是如何实现的？]

如果在加锁时，指定了锁超时时间，那么就算你获取锁成功了，也不会开启watchdog的定时任务了，此时直接就将当前持有这把锁的过期时间、设置为你指定的超时时间，那么当你指定的时间到了之后，key失效被删除了，key对应的锁相应也就自动释放了。



在分布式系统开发当中，分布式锁的使用场景还是很常见的。

### Redis哨兵模式

![Redis哨兵](Redis分布式锁.assets/Redis哨兵.png)

#### Redis哨兵的作用

- 通过发送命令，让Redis服务器返回其监控的运行状态，包括主服务器和从服务器；
- 当哨兵监测到master宕机，会自动将slave切换为master；
- 然后通过发布订阅模式通知其它的从服务器，修改配置文件，让它们切换主机。

### Redis分布式锁

#### 使用场景

实验室项目中，同步数据的后台线程类里边，在好几个地方都运用了分布式锁（使用的是`redis的setNx命令`）。

详见 "捋思路"-实验室-同步数据的笔记。

#### 什么是分布式锁

在分布式系统里面，如果多个机器上的服务要同时对一个共享资源进行操作，比如修改数据库里的一份数据，此时的话，某台机器就需要先获取一个针对那个资源（比如数据库里的某一条数据）的分布式锁。

获取到了分布式锁之后，就可以任由你去查询那条数据，修改那条数据，或者做其它的什么操作。在这个期间，没有任何其它的客户端可以来修改这条数据。

获取了一个分布式操作之后，就对某个共享的数据获取了一定时间范围内的独享操作。

#### redisson分布式锁的隐患

1. redis加锁，本质上就是在redis集群中挑选一个master实例来加锁；

2. 每一个master都挂载了一个slave实例，实现搞可用的机制，如果master宕机，slave就会自动切换为master。

但是还是会有一个老生常谈的问题：

假设客户端刚刚在master写入一个锁，此时发生了master的宕机，但是master还没来得及将那个锁key异步同步到slave，slave就切换为新的master。

此时别的客户端在新的master上也尝试获取同一个锁，成功获取到锁。

这时就会出现两个客户端，都会获取同一把分布式锁，可能有的时候就会导致一些数据的问题。

redisson的分布式锁，隐患主要就在这里。

### MultiLock锁

redisson分布式锁这块是支持MultiLock这个机制的。可以将多个锁合并为一个大锁，对一个大锁进行统一的申请，以及释放锁。

#### 使用场景

在项目里，有很多时候需要一次性锁定多个资源，比如锁掉一个库存，锁掉一个订单，锁掉一个积分，一次性锁掉多个资源，这多个资源不允许别人进行修改，然后你再一次性更新多个资源，最后释放资源。

#### 总结

MultiLock锁的源码，就是包裹了多个RedissonLock，底层就是尝试依次对每个锁都要成功加锁，如果所有锁都成功加锁了之后，那么就认为MultiLock加锁成功了。

释放锁时，依次对每个锁进行释放就可以了。

