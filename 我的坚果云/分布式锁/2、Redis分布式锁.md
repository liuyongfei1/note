技术分享即将结束，再给各位同学来一个彩蛋

【面试题剖析】

[1、相同客户端线程是如何实现可重入加锁的？]

第一次加锁时，会往key对应的hash数据结构中设置 UUID:ThreadId 1，表示当前线程对key加锁一次；

如果相同线程来再次对这个key加锁，只需要将UUID:ThreadId持有锁的次数加1即可，就为：UUID:ThreadId 2 了，Redisson底层就是通过这样的数据结构来表示重入加锁的语义的。


[2、其他线程加锁失败时，底层是如何实现阻塞的？]

线程加锁失败了，如果没有设置获取锁超时时间，此时就会进入一个while的死循环中，一直尝试加锁，直到加锁成功才会返回。

[3、客户端宕机了，锁是如何释放的？]

客户端宕机了，相应的watchdog后台定时任务当然也就没了，此时就无法对key进行定时续期，那么当指定存活时间过后，key就会自动失效，锁当然也就自动释放了。

[4、客户端如何主动释放持有的锁？]

客户端主动释放锁，底层同样也是通过执行lua脚本的方式实现的，如果判断当前释放锁的key存在，并且在key的hash数据结构中、存在当前线程的加锁信息，那么此时就会扣减当前线程对这个key的重入锁次数。

扣减线程的重入锁次数之后，如果当前线程在这个key中的重入锁次数为0，此时就会直接释放锁，如果当前线程在这个key中的重入锁次数依然还大于0，此时就直接重置一下key的存活时间为30s。


[5、客户端尝试获取锁超时的机制在底层是如何实现的？]

如果在加锁时就指定了尝试获取锁超时的时间，如果获取锁失败，此时就不会无止境的在while死循环中一直获取锁，而是根据你指定的获取锁超时时间，在这段时间范围内，要是获取不到锁，就会标记为获取锁失败，然后直接返回false。


[6、客户端锁超时自动释放机制在底层又是如何实现的？]

如果在加锁时，指定了锁超时时间，那么就算你获取锁成功了，也不会开启watchdog的定时任务了，此时直接就将当前持有这把锁的过期时间、设置为你指定的超时时间，那么当你指定的时间到了之后，key失效被删除了，key对应的锁相应也就自动释放了。



在分布式系统开发当中，分布式锁的使用场景还是很常见的。

### Redis的两种持久化方式

#### RDB

Redis Database，是redis默认的持久化策略。RDB持久化是指在指定的时间间隔（可以通过redis.conf里的配置参数来控制时间间隔）内，将内存中的数据集快照写入磁盘。假如连续增长，但redis还没来得及进行持久化，这时redis就挂掉了，重启redis后，就会出现id重复的情况。

#### AOF

Append Only File，redis 会将收到的每一个写命令都通过write函数追加到文件中去，通俗的理解就是日志记录。

AOF 会被每条命令都进行持久化，即使Redis 挂掉了再重启也不会出现id重复的情况，但由于incr命令的特殊性，会导致redis重启恢复的数据时间过长。

### Redis哨兵模式

Redis Sentinel 是 2.8 版本后推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。

![Redis哨兵](Redis分布式锁.assets/Redis哨兵.png)

#### Redis哨兵的作用

- 通过发送命令，让Redis服务器返回其监控的运行状态，包括主服务器和从服务器；
- 当哨兵监测到master宕机，会自动将slave切换为master；
- 然后通过`发布订阅模式通知其它的从服务器，修改配置文件，让它们切换主机`。

### Redis分布式锁

#### 使用场景

实验室项目中，同步数据的后台线程类里边，在好几个地方都运用了分布式锁（使用的是`redis的setNx命令`）。

详见 "捋思路"-实验室-同步数据的笔记。

#### 什么是分布式锁

在分布式系统里面，如果多个机器上的服务要同时对一个共享资源进行操作，比如修改数据库里的一份数据，此时的话，某台机器就需要先获取一个针对那个资源（比如数据库里的某一条数据）的分布式锁。

获取到了分布式锁之后，就可以任由你去查询那条数据，修改那条数据，或者做其它的什么操作。在这个期间，没有任何其它的客户端可以来修改这条数据。

获取了一个分布式操作之后，就对某个共享的数据获取了一定时间范围内的独享操作。

#### 使用setnx分布式锁的注意点

http://news.sohu.com/a/535960528_121124377

20220425日补充：

死锁的两个场景：

1. 有可能客户端a加完锁，执行业务逻辑，还没来得及释放锁呢，结果客户端挂了，这时别的客户端就一直加不上锁，就会造成了死锁；=》解决办法是，设置 expire 过期时间。
2. 客户端a加完锁，但同样还还有这个问题，加锁成功了，但是设置 exprie的时候，客户端挂掉了。

解决办法，将 setnx 和 expire 这两个操作放在一个 原子操作里：

1. 比如，使用lua脚本：

```lua
public boolean tryLock_with_lua(String key, String UniqueId, int seconds) 
	{ String lua_scripts = "if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then" + "redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end"; List keys = new ArrayList<>(); List values = new ArrayList<>(); keys.add(key); values.add(UniqueId); values.add(String.valueOf(seconds)); Object result = jedis.eval(lua_scripts, keys, values); 
 //判断是否成功 return result.equals(1L);}
```

2. **直接使用 set(key,value,NX,EX,timeout) 指令，同时设置锁和超时时间**

   redis.call(" SET", "lock", "true", "NX ", "PX ", "10000")

3. 释放锁的脚本两种方式都是一样的，直接调用 Redis 的 del 指令即可。

这样就完美了吗？

**假设有这样一种情况，如果一个持有锁的应用，其持有锁的时间超过了我们设定的超时时间，会怎么样呢？**

会出现两种情况：

- 发现系统在redis中设置的key 不存在了；
- 发现系统在redis中设置的key 还存在；

 出现第一种情况比较正常了，因为毕竟你执行任务超时了，key被正常清除也是符合逻辑的；

出现第二种情况，发现设置的key还存在，这说明了什么？`说明当前存在的key，是另外的应用设置的。`

`这时候如果持有锁超时的应用执行del 指令去删除时，就会把别人设置的锁误删除，这就会直接导致系统出现问题。`

所以为了解决这个问题，需要对redis脚本进行改动：

1. 首先，在获取锁的时候，去设置一个只有应用自己知道的独一无二的值；

   ```lua
   if redis.call( "SETNX", "lock", ARGV[ 1]) == 1 then 
     local expireResult = redis.call( "expire", "lock", "10") 
     if expireResult == 1 then return "success" 
      else return "expire failed" 
     end 
   else return "setnx not null" end
   ```

   或

   ```bash
   redis.call(" SET", "lock", ARGV[1], "NX ", "PX ", "10000")
   ```

   这里，ARGV[1] 是一个可传入的参数变量，可以传入唯一值。比如一个只有自己知道的 UUID 的值，或者通过雪球算法，生成只有自己持有的唯一 ID。

2. 释放锁的脚本改成这样：

   ```lua
   if redis.call( "get", "lock") == ARGV[ 1] then 
   return redis.call( "del", "lock") 
   else return 0 end
   ```

   

听起来有点复杂，但是实际中我们可以使用已经封装好的框架，比如 **redisson**，使用 lock  和unlock 就行了。

#### redisson分布式锁的隐患

1. redis加锁，本质上就是在redis集群中挑选一个master实例来加锁；

2. 每一个master都挂载了一个slave实例，实现高可用的机制，如果master宕机，slave就会自动切换为master。

但是还是会有一个老生常谈的问题：

假设客户端刚刚在master写入一个锁，此时发生了master的宕机，但是master还没来得及将那个锁key异步同步到slave，slave就切换为新的master。

此时别的客户端在新的master上也尝试获取同一个锁，成功获取到锁。

这时就会出现两个客户端，都会获取同一把分布式锁，可能有的时候就会导致一些数据的问题。

`redisson的分布式锁，隐患主要就在这里。`



### MultiLock锁

redisson分布式锁这块是支持MultiLock这个机制的。可以将多个锁合并为一个大锁，对一个大锁进行统一的申请，以及释放锁。

#### 使用场景

在项目里，有很多时候需要一次性锁定多个资源，比如锁掉一个库存，锁掉一个订单，锁掉一个积分，一次性锁掉多个资源，这多个资源不允许别人进行修改，然后你再一次性更新多个资源，最后释放资源。

#### 总结

MultiLock锁的源码，就是包裹了多个RedissonLock，底层就是尝试依次对每个锁都要成功加锁，如果所有锁都成功加锁了之后，那么就认为MultiLock加锁成功了。

释放锁时，依次对每个锁进行释放就可以了。

