### 多级缓存机制降低对服务注册表的锁争用

register-server：ServiceRegistryCache 注册表缓存

1. 系统刚启动的时候，只会有一个线程来进行加写锁，然后填充数据，填充完数据就释放锁了；
2. 服务注册表变更的时候，会走过期，过期的时候用的readWrite锁；
3. 30S后，也是用的readWrite锁，这个时候的写锁可能会跟前面的读锁有冲突，但由于是每隔30S，所以冲突的频率已经很低了；



三种锁：

1. 服务注册表的锁；
2. readOnlyMap的锁；
3. readWriteMap的锁；



#### 为什么用两级缓存，而不是用一级缓存？

用一级缓存的话，会导致

- 频繁的加写锁，更新这个map；
- 读这个map的时候又需要加读锁，这样就频繁的加读锁
- 这样就会造成读写锁的频繁争用，用一级缓存就没什么意义了。

#### 总结

在拉取注册表的时候：

- 首先从ReadOnlyCacheMap里查缓存的注册表；
- 若没有，就找ReadWriteCacheMap里缓存的注册表；
- 如果还没有，就从内存中获取实际的注册表数据。

在注册表发生变更的时候：

- 会在内存中更新变更的注册表，同时过期掉ReadWriteCacheMap；
- 此过程不会影响ReadOnlyCacheMap提供人家查询注册表，一段时间内（默认30s），各服务拉取注册表会直接读ReadOnlyCacheMap；
- 30s后，Eureka Server的后台线程会发现ReadWriteCacheMap被清空了，则会将ReadOnlyCacheMap也清空。
- 下次，再有服务拉取注册表，就会从内存中获取最新的数据了，同时填充各个缓存。



死锁



锁死



线程饥饿

  一直在排队，但却一直被后面的线程先抢到加锁。

 将非公平锁 修改为 公平锁，先到的先加锁，就不会出现线程饥饿。



活锁

 比线程饥饿更严重一点，线程一直运行着，却一直获取不到锁，不能完成任务。

