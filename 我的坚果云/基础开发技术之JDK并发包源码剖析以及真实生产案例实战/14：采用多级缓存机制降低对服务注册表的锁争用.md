### 多级缓存机制降低对服务注册表的锁争用

register-server：ServiceRegistryCache 注册表缓存

1. 系统刚启动的时候，只会有一个线程来进行加写锁，然后填充数据，填充完数据就释放锁了；
2. 服务注册表变更的时候，会走过期，过期的时候用的readWrite锁；
3. 30S后，也是用的readWrite锁，这个时候的写锁可能会跟前面的读锁有冲突，但由于是每隔30S，所以冲突的频率已经很低了；



三种锁：

1. 服务注册表的锁；
2. readOnlyMap的锁；
3. readWriteMap的锁；



#### 为什么用两级缓存，而不是用一级缓存？

用一级缓存的话，会导致

- 频繁的加写锁，更新这个map；
- 读这个map的时候又需要加读锁，这样就频繁的加读锁
- 这样就会造成读写锁的频繁争用，用一级缓存就没什么意义了。



死锁



锁死



线程饥饿

  一直在排队，但却一直被后面的线程先抢到加锁。

 将非公平锁 修改为 公平锁，先到的先加锁，就不会出现线程饥饿。



活锁

 比线程饥饿更严重一点，线程一直运行着，却一直获取不到锁，不能完成任务。

