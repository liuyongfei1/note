### spring源码编译-准备工作

#### 下载spring源码

使用5.2.19 RELEASE 版本的：

https://github.com/spring-projects/spring-framework.git

spring容器，从代码上理解的话其实就是`AnnotationConfigApplicationContext`这个对象。

详细步骤见： /Users/lyf/study/2021年/儒猿/子路-spring5/01_课前基础知识资料。

#### 建自己的Module

同时使用的是本地的依赖，而不是远程的jar包。

```java
package com.fullstackboy;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * 测试使用目前的这套编译后的源码来讲将自己建的Bean1这个类放到Spring容器中 是否生效
 *
 * @author Liuyongfei
 * @date 2021/12/25 22:34
 */
public class Test {
	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(Bean1.class);
		context.refresh();
		System.out.println(context.getBean(Bean1.class));
	}
}
```

输出结果：

```java
com.fullstackboy.Bean1@5d6f64b1
```



### Spring日志现象

体会一下：

目前存在有:

 logback-classic、

compile("org.slf4j:slf4j-api")、

compile("org.apache.logging.log4j:log4j-core")、

也就是当前存在有logback + logback的绑定器 + slf4j + log4j2，但是并没有log4j2的绑定器。

所以 @Slf4j ，然后

```java
@Slf4j
public class Test1 {
  @Test
  public void test() {
    log.debug("----");
  }
}
```

// 会查找绑定器，发现只有logback的绑定器，于是会实例化出来logback。

如果你使用了spring的日志技术（什么叫spring的日志技术？=》也就是说你使用的是spring-jcl这个项目中的日志），比如spring的源码，那么就会被log4j2给覆盖。

------------------------------------------------------------------

spring-boot 默认是用`logback`打印日志的。

spring-boot为什么默认采用logback？

### 众多的日志框架

#### java.util.logging.Logger

它是伴随着java发布的时候就有的。

使用：

```java
import java.util.logging.Logger;
Logger logger = Logger.getLogger("a")
logger.info("gul");
```

它打印的日志是特别明显的，文字颜色是红色的。

#### Log4j

然后市面上又出现了一个新的日志框架，就是Log4j，需要有一个配置文件log4j.properties，进行配置。

使用：

```java
import org.apache.log4j.Logger;
Logger logger = Logger.getLogger("a")
logger.info("log4j");
```

#### commons-logging

第三个commons-logging.jar，全称是 jarkartCommons-logging，为了解决这个硬编码。但现在已经被淘汰了，2014年已经不更新了。spring把这个jar拿过来在它的基础上形成了spring-jcl。

#### Slf4j

slf4j是通过绑定器来和具体日志框架工作的。

