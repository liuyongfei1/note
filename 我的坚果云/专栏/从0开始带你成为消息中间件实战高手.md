## 从0开始带你成为消息中间件实战高手

### 009_系统面临的现实问题：大数据团队需要订单数据，该怎么办？

#### 大数据到底是干嘛的？

做为公司的老板，他可能每天到公司来的第一件事儿就是要看看昨天的销售额是多少，卖了多少件商品。可能还想要知道一共有多少个用户在我们这里购买了商品？一共有多少个订单？每个商品分别卖了多少？哪个商品是卖的最火爆的？我们的APP昨天有多少人打开了？打开APP里的人有多少人下订单购物了？

老板拿到这些数据后，才能继续去考虑公司的运用策略。

比如老板拿到这份数据后，觉得用户量还是太少了，要抓紧投放广告，多拉一些人来购物。

因此，听明白了上面这段描述，你一定就能理解什么是大数据，以及大数据团队是干什么的了。

很简单，上面说的老板每天上班的第一件事儿要了解的那些数据，其实就是大数据。

所以如果每天有100万用户来访问你的APP，积累下来的一些浏览行为、访问行为、交易行为等各种数据，这个数据量很大，所以你可以称之为"大数据"。

**大数据团队每天要负责的事情，说白了就是去尽可能的搜集每天100万用户在你APP上的各种行为数据。**

### 015_解决订单系统诸多问题的核心技术：消息中间件到底是什么？

所谓消息中间件其实就是一种系统，它自己也是独立部署的，然后我们的两个系统之间通过发消息和收消息，来进行异步的调用，而不是仅仅局限于同步调用。

MQ进行流量削峰的效果：系统A发送过来的每秒1万请求是一个流量洪峰，然后MQ直接扛下来了，都存储在自己本地磁盘里，这个过程就是流量削峰的过程，瞬间把一个洪峰给削下来了，让系统B后续慢慢获取消息来处理。

### 021_设计生产架构之前的功课：消息中间件路由中心的架构是什么？

RocketMQ 的核心其实包含了四个部分：

1. 第一块就是他的 NameServer，这个东西很重要，他负责管理集群所有的Broker信息，让使用MQ的系统通过他可以感知到集群里有哪些Broker；
2. 第二块就是Broker集群本身了，必须得在多台机器上部署这么一个集群，而且还得用主从架构实现数据多副本存储和高可用。
3. 第三块就是像MQ发送消息的那些系统了，这些系统一般称之为生产者，这里也有很多细节是值得深究的，因为这些生产者到底是如何从NameServer拉取路由信息的？如何选择Broker机器简历连接以及发送消息的？
4. 第四块就是从MQ获取消息的那些系统，这些系统称之为消费者。仔细想想消费者这块其实也隐藏了很多技术细节，比如到底是Broker主动推送消息给消费者，还是消费者自己从Broker里拉取消息？这些也都很值得深究。

#### 关于NameServer

##### 1、Broker是把自己的信息注册到哪个NameServer上？

答案：每个 broker 启动都得向所有的NameServer进行注册。

##### 2、系统如何从NameServer获取Broker信息？

每个系统（生产者或消费者）自己每隔一段时间，定时发送请求到NameServer去拉取最新的集群Broker信息。

##### 3、如果Broker挂了，NameServer是怎么感知到的？

要解决这个问题，靠的是 Broker 和 NameServer 之间的心跳机制，Broker 会每隔 30秒 给说有的 NameServer 发送心跳，告知每个 NameServer 自己目前还活着。

每次NameServer 收到一个 Broker 的心跳，就可以更新一下他的最近一次心跳的时间。

然后NameServer 会每隔10s 运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker 超过120s 都没发送心跳了，那么就认为这个Broker已经挂掉了。

##### 4、Broker 挂了，系统是怎么感知的

这里先说一下思路，等后边分析生产者原理的时候会说具体的细节。

大家想一下，可以有两种解决办法：

- 首先，你可以考虑不发送消息给那台 Broker，改成发给其它 Broker；
- 其次，假设你必须发送消息给那台 Broker，那么他挂了，他的 Slave 机器是一个备份，可以继续使用，你是不是可以考虑等一会儿去跟他的 Slave 进行通信？
- 总之，这些都是死路，但是现在我们知道，对于生产者而言，他是有一些容错机制的，即使一下子没感知到某个 Broker 挂了，他可以有别的方案去应对；
- 而且，过一会儿，系统又会重新从 NameServer 拉取最新的路由信息了，此时就会知道有一个 Broker 已经宕机了。

### 021_设计生产架构之前的功课：Broker的主从架构原理是什么？

#### 2、Master Broker是如何将消息同步给 Slave Broker的？

RocketMQ 的Master-Slave 模式采取的是 Slave Broker 不停的发送请求到 Master Broker去拉取消息。

#### 3、RocketMQ 实现读写分离了吗？

下一个问题，既然 master broker 主要是接收系统的消息写入，然后会同步给 broker，那么其实本质上 slave broker 也应该有一分一样的数据。

所以这里提出一个疑问，做为消费者的系统在获取消息的时候，是从 master broker 获取的？还是从 slave broker 获取的？

其实都不是，答案是：有可能从 master broker 获取，也有可能从 slaver broker 获取。

做为消费者的系统在获取消息的时候会发送请求到 master broker 上，请求获取一批消息，此时 master broker是会返回一批消息给消费者系统的。

然后 master broker 在返回消息给消费者系统的时候，**会根据当时 master broker 的负载情况和slave broker 的同步情况**，**向消费者建议下一次拉取消息的时候**是从 master broker拉取还是从 slave broker 拉取。

举个例子，要是这个时候 master broker 负载很慢，本身要扛10万写并发了，你还要从他这里拉取消息，给他加重负担，那肯定是不合适的。

所以，此时master broker 就会建议你从 slave broker去拉取消息。

#### 4、如果Slave Broker挂掉了有什么影响？

有一点影响，但影响不大。

如果 Slave Broker 挂掉了，那么此时无论消息写入还是消息拉取，还是可以继续从 master broker 去走，对整体运行不影响。只不过少了 slave broker，会导致所有读写压力都集中在 master broker上。

#### 5、如果Master Broker挂掉了该怎么办？

现在假设出现了一个故障，master broker突然挂了，这样会怎么样？

这时候就对消息写入和获取都有一定影响了。但是其实本质上而言，slave broker 和master broker 一样都有一份数据再的，只不过slave broker上的数据可能有部分没来得及从master broker同步。

但是此时 RocketMQ 可以实现直接自动将Slave Broker切换为 Master Borker吗？

答案是：不能。

在RocketMQ 4.5版本之前，都是用 Slave Broker同步数据，尽量保证数据不丢失，但是一旦 Master故障了，Slave是没法自动切换成Master的。

所以在这种情况下，如果Master broker宕机了，这时就得手动做一些运维工作，把 slave broker重新修改一下配置，重启机器给调整为master broker，这是有点麻烦，而且会导致中间件一段时间不可用。

所以这种 Master-Slave 模式不是彻底的高可用模式，他没法实现自动把Slave切换为Master。

#### 6、基于Dledger实现RocketMQ高可用自动切换

在RocketMQ 4.5之后，这种情况得到了改变，因为RocketMQ支持了一种新的机制，叫做Dledger。

原理有点复杂。

简单来说，把 Dledger 融入 RocketMQ 之后，就可以让一个 master broker 对应多个 slave broker，也就是说一个数据可以有多份副本。

此时一旦master broker 宕机了，就可以在多个slave之间，通过Dledger技术和Raft协议算法进行leader选举，直接将一个slave broker选举为新的master broker，然后这个新的master broker就可以对外提供服务了。

整个过程也许只要10秒钟或者几十秒钟就可以完成。

Dledger所以，索道这里，我们在设计 RocketMQ 生产部署的时候，完全可以采用基于Dledger的部署方式，这样就可以让  RocketMQ 做到自动故障切换了。