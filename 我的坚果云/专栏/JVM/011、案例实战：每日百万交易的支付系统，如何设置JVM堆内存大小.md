## 011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小

### 4、每日百万交易的支付系统的压力在哪里

每日百万交易的订单，在JVM角度来看，就是每天会在JVM中创建上百万个支付订单对象。

单单在JVM层面来看，我们支付系统的最大压力，就是每天JVM内存里会频繁的创建和销毁100万个支付订单，所以这里就牵涉到一个核心问题：

- 我们的支付系统需要部署多少台机器？
- 每台机器需要多大的内存空间？
- 每台机器上启动的JVM需要分配多大的堆内存空间？
- 给JVM多大的内存空间，才可以保证可以支撑这么大的订单在内存里的创建，而不会导致内存不够直接崩溃？

这是我们本文要考虑的核心问题。

### 5、支付系统每秒钟处理多少笔支付订单

第一个核心参数就是 JVM堆内存大小的合理设置。

我们第一个要计算的，就是每秒钟我们的系统要处理多少笔支付订单。

假设每天100个支付订单，那么用户的支付行为一般就发生在每天的高峰期，比如中午或晚上。

假设每天的高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概是每秒100笔订单左右。

咱们就以每秒100笔订单来计算一下好了。

假设我们的支付系统部署了3台机器，**那么每台机器实际上每秒大概处理30笔订单**。

### 6、每个支付订单处理要耗时多久

如果用户发起一次支付请求，那么支付需要在JVM中创建一个支付订单对象，填充进数据，然后把这个订单写入数据库，还可能处理一些其它的事情。

咱们就假设一次支付请求的处理，包含订单的创建，大概需要1秒钟的时间。

那么大体上你的脑子里可能出现的一个流动模型，应该是每台机器每一秒钟收到30笔支付订单的请求，**然后在JVM里创建30个支付订单的对象**，做了写入数据库处理。

接着1秒之后，这30个订单就处理完毕，然后对这些支付订单对象的引用就回收了，这些订单对象在JVM就是没人引用的垃圾对象了。

接着再是下一秒来30个订单，重复这个步骤。

### 7、每个支付订单大概需要多大的内存空间

这个怎么算呢？就直接根据支付订单类中的实例变量的类型来计算就可以了。

比如支付订单类如下所示，你只要记住一个Integer类型的变量数据是4个字节，Long类型的变量数据是8个字节，还有别的类型的变量占据多少字节。

就可以计算出，每个订单对象，大概占据多少个字节。

```java
public class PayOrder {
	private Integer userId;
  private Integer orderTime;
  private Integer orderId;
}
```

一般来说，比如支付订单这种核心类，你就按20个实例变量来计算，然后一般一个对象大概也就几百个字节的样子。

我们算他大一点好了，就算一个支付订单对象占据 500 字节的内存空间，不到1b。

### 8、每秒发起的支付请求对内存的占用

在1秒内，大概有 30 * 500字节 = 15000 字节，大概其实也就就15kb而已。其实是非常非常小的。

### 9、让支付系统运行起来分析一下

现在已经把整个系统运行的关键环节的数据都分析清楚了，大家可以大致脑子里思考一下，每秒30个支付请求，创建30个支付订单对象，也就占据KB级别的内存而已。

然后接着1秒过后，这30个对象就没人引用了，就成了新生代里的垃圾了。

下一秒请求过来，我们的系统持续的创建支付订单对象，不停的新生代里放入30个支付订单，然后新生代里的对象会持续的累计和增加。

`直到有一刻，发现新生代里可能有几十万对象了，此时占据了几百MB的空间，可能新生代空间就快满了。`

`然后就会触发Yong GC，就把新生代里的垃圾对象都给回收了，腾出空间，然后继续来在内存里分配新的对象。`

这就是这个业务系统的运行模型。

### 10、对完整的支付系统内存占用需要进行预估

之前的分析，全部都是基于一个核心业务流程中的一个**支付订单对象**来分析的，其实那只是一小部分而已。

真实的支付系统线上运行，肯定每秒会创建大量其他对象。

我们可以估算一下整个支付系统每秒钟大概会占据多少内存空间。

其实如果你要估算的话，可以把之前的计算结果扩大10-20倍。

那么**每秒钟创建出来**的`被栈内存的局部变量引用的对象`大致占据的内存空间就在`几百KB~1MB`之间。

然后下一秒继续来新的请求创建大概1MB的对象在新生代里，接着变成垃圾，再来一秒。

循环多次之后，新生代里垃圾太多，就会触发Yong GC 回收掉这些垃圾。**这就是一个完整系统的大致JVM层面的内存使用模型。**

### 11、支付系统的JVM堆内存该怎么设置

线上业务系统，常见的机器配置是2核4G，或者是4核8G。

如果是2核4G的机器，机器本身也要用掉一部分内存，最后留给你的JVM进程最多也就2G内存。

然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是个1G内存。

堆内存还分为新生代和老年代，你的老年代总需要放置一些长期存活的对象吧，怎么也得给个几百MB内存空间，那么留给新生代的也就几百MB内存了。

`那么如果你的新生代就几百MB的内存空间，是不是会导致系统运行几百秒之后，新生代的空间就满了？此时是不是得触发 Yong GC 了？`

其实如果这么频繁的触发Yong GC，会影响线上系统的稳定性。具体原因后续再说。

此时，你可以考虑采用4核8G的机器，那么JVM可以分配到4G内存，新生代里面可以分配到2G的内存。

`这样子就可以做到可能新生代每秒多1MB的内存，但是需要将近半小时到1小时才会让新生代触发Yong GC，这就大大降低了 GC 的频率。`

举个例子，机器采用4核8G，然后-Xms和-Xmx设置为3G，给整个堆内存分配3G内存空间，-Xmn设置为2G，给新生代设置2G内存空间。

而且假设你的业务更大，可以考虑部署5台，10台机器，这样每台机器处理的请求更少，对JVM的压力更小。

