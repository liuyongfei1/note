# 手把手带你吃透Spring框架核心源码

## 备注

主要笔记来自 儒猿技术窝：https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_620dbc7de4b04d7e2fcca5a0/6

在学习的时候可以结合 <<手撸Spring>>* 小傅哥.pdf 及学习笔记一块学习。https://github.com/fuzhengwei/small-spring

## 03-Resource 到底是个什么玩意儿

### 初始ClassPathResource

从 ClassPathResource 加载 applicationContext.xml 开始，了解下 ClassPathResource 是什么。

ClassPathResource 其实就是一个实现了 Resource 接口的实现类而已。和 ClassPathResource 类似的还有 UrlResource、FileSystemResource 和 InputStreamResource，它们都实现了 Resource 接口，而 Resource 接口又实现了 InputStreamSource 接口。

### Resource和InputStreamSource

首先，我们来回答第一个问题：什么是 Resource 接口？ =》`Spring 统一把所有使用到的资源都抽象成了 Resource，不同来源的资源对应着不同的 Resource 实现类。`

我们可以来看一下 Resource 接口中，都有哪些方法：

<img src="1.assets/image-20220309133257298.png" alt="image-20220309133257298" style="zoom:50%;" />

再来看看 InputStreamSource 接口是什么呢？

<img src="1.assets/image-20220309133427559.png" alt="image-20220309133427559" style="zoom:50%;" />

可以看到 InputStreamSource 接口中只有一个方法 getInputStream，而且方法返回的就是要给输入流 InputStream。

这也就意味着所有资源只要封装成了Resource，就可以通过调用 InputStreamResource 中的 getInputStream方法，获取资源对应的输入流 InputStream 了。

### 各种Resource是如何加载资源的呢？

ClassPathResource：

```java
public class ClassPathResource implements Resource {

    private final String path;

    private ClassLoader classLoader;

    public ClassPathResource(String path) {
        this(path, (ClassLoader) null);
    }

    public ClassPathResource(String path, ClassLoader classLoader) {
        Assert.notNull(path, "Path must not be null");
        this.path = path;
        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
    }

    @Override
    public InputStream getInputStream() throws IOException {
        InputStream is = classLoader.getResourceAsStream(path);
        if (is == null) {
            throw new FileNotFoundException(
                    this.path + " cannot be opened because it does not exist");
        }
        return is;
    }
}
```

就是通过 classLoader 的底层方法来加载的，没什么特别的地方。

FileSystemResource：

```java
public class FileSystemResource implements Resource {

    private final File file;

    private final String path;

    public FileSystemResource(File file) {
        this.file = file;
        this.path = file.getPath();
    }

    public FileSystemResource(String path) {
        this.file = new File(path);
        this.path = path;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return new FileInputStream(this.file);
    }

    public final String getPath() {
        return this.path;
    }

}
```

更简单，无非是通过 JDK 底层方法，根据文件的路径去加载资源的 InputStrean。

UrlResource：

```java
public class UrlResource implements Resource{

    private final URL url;

    public UrlResource(URL url) {
        Assert.notNull(url,"URL must not be null");
        this.url = url;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        URLConnection con = this.url.openConnection();
        try {
            return con.getInputStream();
        }
        catch (IOException ex){
            if (con instanceof HttpURLConnection){
                ((HttpURLConnection) con).disconnect();
            }
            throw ex;
        }
    }

}
```

通过对应 URL 连接去获取 InputStream。

## 04-Spring初级容器初始化：忽略指定接口自动装配功能

单元测试代码：

```java
XmlBeanFactory beanFactory= new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
Bean1 bean1 = (Bean1) beanFactory.getBean("bean1");
System.out.println(bean1);
```

### 初探ignoreDependencyInterface方法

1、XmlBeanFactory构造函数：

```java
/**
	 * Create a new XmlBeanFactory with the given resource,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource) throws BeansException {
		this(resource, null);
	}

	/**
	 * Create a new XmlBeanFactory with the given input stream,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @param parentBeanFactory parent bean factory
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
		this.reader.loadBeanDefinitions(resource);
	}
```

2、先来看父类构造函数干了些什么：

```java
/**
	 * Create a new AbstractAutowireCapableBeanFactory.
	 */
	public AbstractAutowireCapableBeanFactory() {
		super();
		ignoreDependencyInterface(BeanNameAware.class);
		ignoreDependencyInterface(BeanFactoryAware.class);
		ignoreDependencyInterface(BeanClassLoaderAware.class);
	}
```

### ignoreDependencyInterface方法是干什么的呢

```java
public void ignoreDependencyInterface(Class<?> ifc) {
  this.ignoredDependencyInterfaces.add(ifc);
}
```

ignoredDependencyInterfaces 就是个 Set 集合，也就是将这三个 Aware 放入 Set 集合。

搜了一下代码，ignoredDependencyInterfaces 只在 isExcludedFromDependencyCheck的方法中用到了：

```java
/**
	 * Determine whether the given bean property is excluded from dependency checks.
	 * <p>This implementation excludes properties defined by CGLIB and
	 * properties whose type matches an ignored dependency type or which
	 * are defined by an ignored dependency interface.
	 * @param pd the PropertyDescriptor of the bean property
	 * @return whether the bean property is excluded
	 * @see #ignoreDependencyType(Class)
	 * @see #ignoreDependencyInterface(Class)
	 */
	protected boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {
		return (AutowireUtils.isExcludedFromDependencyCheck(pd) ||
				this.ignoredDependencyTypes.contains(pd.getPropertyType()) ||
				AutowireUtils.isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));
}
```

根据这个方法的注释可以知道，这个方法的作用就是明确一个bean的属性是否要从依赖检查中排除掉。

```java
/**
 * Return whether the setter method of the given bean property is defined
 * in any of the given interfaces.
 * @param pd the PropertyDescriptor of the bean property
 * @param interfaces the Set of interfaces (Class objects)
 * @return whether the setter method is defined by an interface
 */
public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {
   Method setter = pd.getWriteMethod();
   if (setter != null) {
      Class<?> targetClass = setter.getDeclaringClass();
      for (Class<?> ifc : interfaces) {
         // 判断属性所在的类，是否实现了这些Aware接口
         // 并且在这些感知接口中，是否也存在相同的setter方法
         if (ifc.isAssignableFrom(targetClass) && ClassUtils.hasMethod(ifc, setter)) {
            return true;
         }
      }
   }
   return false;
}
```

这个方法主要判断两点：

- 一是bean的属性对应的类，是否实现了 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware的某个接口；
- 二是这个bean属性对应的setter方法，在这三个感知接口中是否也存在相同的方法。

如果同时满足这两点，方法 isSetterDefinedInInterface 就会返回true，Spring 在自动装配时也就是在创建这个bean时，就不会给该属性注入值了。

来看这个demo，可能会更容易理解：

src/test/java/com/fullstackboy/springdemo/bean/AwareTest.java

我们从输出结果中可以看出：

就算在 xml 中为属性设置了值，最终也不能注入到 bean 的属性 beanName 中。

而这个结果，其实就是 Spring 内部调用了 BeanNameAware 接口的 setBeanName 方法，为 User2 设置了 beanName 属性的值。

`分析到这里其实已经真相大白了，也就是说如果一个 bean 实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware的某个接口的话，那个 bean 中的属性值如果想要通过 Spring 进行自动装配赋值的话，这个属性对应的 setter 方法，就不能和 感知接口中的方法相同。`

如果相同的话，Spring 就不会为给属性自动装配赋值，而是让 Spring 内部自动调用这些感知接口的方法，来为这些属性赋值。

- 这也是这些感知接口存在的意义了，毕竟，bean 都实现了这些感知接口了，而感知接口恰好已经通过方法 ignoreDependencyInterface 添加到忽略感知接口的集合中了，这就相当于这些属性的赋值权利交给 Spring 内部来决定了。

- Spring 这样设计其实也有一定的合理性了，比如你实现了 BeanNameAware 接口，对应的 beanName 属性的值，当然是这个 bean 在 Spring 容器中的名称啊。

- 此时，如果你从外部的 xml 或注解中注入了一个其它的名称，Spring 理所应当就会忽略掉这个外来值的自动装配了，确保 bean 名称的唯一性。

### Spring中的感知接口又是什么呢

<img src="1.assets/image-20220310091858457.png" alt="image-20220310091858457" style="zoom:50%;" />

`当bean实现了这些感知接口时，Spring 在实例化这些 bean 的时候，就会调用感知接口中的方法，注入相应的数据。`

我们用一个例子来演示一下，这个感知接口有什么用？

src/test/java/com/fullstackboy/springdemo/bean/AopTest.java

## 05-Spring初级容器初始化：基础数据的准备

1、再回到 XmlBeanFactory 的构造函数中：

```java
/**
	 * Create a new XmlBeanFactory with the given input stream,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @param parentBeanFactory parent bean factory
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
		this.reader.loadBeanDefinitions(resource);
	}
```

### EncodedResource是什么呢

2、XmlBeanDefinitionReader#loadBeanDefinitions

```java
@Override
	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		return loadBeanDefinitions(new EncodedResource(resource));
	}
```

3、EncodedResource

```java
public EncodedResource(Resource resource) {
  this(resource, null, null);
}

private EncodedResource(Resource resource, @Nullable String encoding, @Nullable Charset charset) {
  super();
  Assert.notNull(resource, "Resource must not be null");
  this.resource = resource;
  this.encoding = encoding;
  this.charset = charset;
}
```

在 EncodedResource 类中，使用到 encoding 和 charset 的地方也就一个地方，getReader 方法：

```java
public Reader getReader() throws IOException {
  if (this.charset != null) {
    return new InputStreamReader(this.resource.getInputStream(), this.charset);
  }
  else if (this.encoding != null) {
    return new InputStreamReader(this.resource.getInputStream(), this.encoding);
  }
  else {
    return new InputStreamReader(this.resource.getInputStream());
  }
}
```

可以看到在getReader中：

- 首先会通过getInputStream 方法获取 resource 的输入流，同时会执行字符集或编码，但是现在我们传入的charset和encoding都为null，所以创建的就是一个没有指定字符集和编码的 InputStreamReader；
- InputStreamReader 大家多少都会了解一点，就是 Java SE IO 流中将字节输入流转换为字符输入流的 API，很明显接下来 Spring 将以字符输入流，读取我们的资源Resource。
  - 字符输入流：FileReader 和 BufferedReader；
  - 字符输出流：FileWriter 和 BufferedWriter；
  - FileReader 类仅仅是 InputStreamReader 类的衍生类并未扩展任何功能；
  - `FileReader 类读取数据实质就是 InputStreamReader 类在读取`，而 InputStreamReader 读取实际是 StreamDecoder 类读取。

### 基础数据的准备工作

了解了 EncodedResource 之后，我们再继续回到刚才的位置，查看 XmlBeanDefinitionReader#loadBeanDefinitions方法：

```java
@Override
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
  return loadBeanDefinitions(new EncodedResource(resource));
}

public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
  Assert.notNull(encodedResource, "EncodedResource must not be null");
  if (logger.isTraceEnabled()) {
    logger.trace("Loading XML bean definitions from " + encodedResource);
  }

  Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();

  if (!currentResources.add(encodedResource)) {
    throw new BeanDefinitionStoreException(
      "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
  }
	
  // 获取 encodedResource的输入流
  try (InputStream inputStream = encodedResource.getResource().getInputStream()) {
    // 通过输入流来构建InputResource，并设置响应的编码
    InputSource inputSource = new InputSource(inputStream);
    if (encodedResource.getEncoding() != null) {
      inputSource.setEncoding(encodedResource.getEncoding());
    }
    // 正式开始加载资源
    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
  }
  catch (IOException ex) {
    throw new BeanDefinitionStoreException(
      "IOException parsing XML document from " + encodedResource.getResource(), ex);
  }
  finally {
    currentResources.remove(encodedResource);
    if (currentResources.isEmpty()) {
      this.resourcesCurrentlyBeingLoaded.remove();
    }
  }
}
```

到这一步，数据准备的工作才算完成，从 doLoadBeanDefinitions 开始就要正式解析 Xml 配置文件了。

## 06-Spring初级容器初始化：加载XML的Document

### Spring是如何解析XML的

XmlBeanDefinitionReader：

```java
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
      // 根据输入流和 resource，创建xml文件对应的Documnet
			Document doc = doLoadDocument(inputSource, resource);
      // 解析Document，并注册bean到Spring容器中
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug("Loaded " + count + " bean definitions from " + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					"Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					"XML document from " + resource + " is invalid", ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"Parser configuration exception parsing XML from " + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"IOException parsing XML document from " + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"Unexpected exception parsing XML document from " + resource, ex);
		}
	}
```

doLoadDocument -》loadDocument

DefaultDocumentLoader#loadDocument

```java
/**
	 * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
	 * XML parser.
	 */
	@Override
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
		}
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		return builder.parse(inputSource);
	}
```

看到这里几乎就真相大白了，Spring其实是通过 DOM 来解析XML文件的。

### XML解析的示例：DOM解析

详细见：/Users/lyf/Workspace/www/blog-demo/test-demo/src/main/java/com/fullstackboy/dmoparsexml/Test.java

### Spring是如何加载Resource的

```java
@Override
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
		}
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		return builder.parse(inputSource);
	}
```

可以看到，Spring加载Resource的方式几乎与案例中是一样的。

最后还有一个疑问，这个entityResolver参数是什么? =》 它是Spring对XML文件的校验。

## 07-Spring初级容器初始化：XML文件的校验模式

https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_620dc453e4b054255d9ebd3e/1?from=p_620dbc7de4b04d7e2fcca5a0&type=6&parent_pro_id=



## 13-Spring初级容器初始化：BeanDefinition是如何注册到Spring容器

这一节，我们找到了 BeanDefinition 注册的入口，发现了 Spring 容器其实就是一个Map，将 bean 注册到 Spring 容器的过程也很简单，就是将 bean name 当做key，以 bean 对应的 BeanDefinition 为 value 注册到这个Map 中去。

另外考虑到线程安全的问题，Spring 容器对应的 Map 也就是 beanDefinitionMap，其实是多线程安全类型的 ConcurrentHashMap。

## 14-Spring高级容器初始化：初探容器ApplicationContext初始化

ApplicationContext 在初级容器（XmlBeanFactory）的基础之上，扩展了非常多的高级特性，同时也给我们提供了非常多的功能扩展点，通过这些功能扩展点，我们可以将 Spring 这个框架的功能改造的更加满足于我们实际业务的场景。

### 初始化容器上下文环境

### 初始化容器BeanFactory

### 加载XML中的BeanDefinition

## 16-Spring高级容器初始化：初步添加扩展功能点

### 添加SPEL语言的支持

在 Spring 创建 bean 的时候，发现 bean 的某个属性值存在表达式 "#{}"（SPEL表达式），就会利用 StandardBeanExpressionResolver 来解析。 

AbstractApplicationContext#prepareBeanFactory

```java
beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
```

为 beanFactory 设置#{...}表达式的解析器。

### 添加属性编辑器的注册器

AbstractApplicationContext#prepareBeanFactory：

```java
beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
```

为 beanFactory 添加属性编辑器 PropertyEditor 的注册器。

```java
public void registerCustomEditors(PropertyEditorRegistry registry) {
		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, Path.class, new PathEditor(baseEditor));
		doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
		}
	}
```

我们来看一个InputStreamEditor：

InputStreamEditor#setAsText：

```java
public void setAsText(String text) throws IllegalArgumentException {
		this.resourceEditor.setAsText(text);
		Resource resource = (Resource) this.resourceEditor.getValue();
		try {
			setValue(resource != null ? resource.getInputStream() : null);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Failed to retrieve InputStream for " + resource, ex);
		}
	}
```

看到这里大家应该明白了吧，首先会通过InputStreamEditor中的setAsText方法传进来一个 String 类型的参数text，然后通过各种解析得到了 InputStream。

同理，我们可以推断出FileEditor、URLEditor 等其它编辑器Editor 是用来将 Spring 解析为相应对象的。

**那为什么我们需要这些属性编辑器，来将字符串 String 转化为各种对象呢？这其实跟 XML 配置文件的局限性有关。**

**Spring 容器会在初始化的时候就会注册各种各样的属性编辑器，当在 bean 实例化需要设置相应的属性值时，这些属性编辑器就会根据相应字符串String解析并转换为相应对象了，并为bean的这些属性赋值，完成bean的实例化。**

### 添加ApplicationContextAwareProcessor

AbstractApplicationContext#prepareBeanFactory：

```java
// 添加执行各种感知接口方法的后处理器
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
```

可以看到，会初始化一个 ApplicationContextAwareProcessor 类型的对象，并添加到 beanFactory 中。

我们能够隐约的感觉到 ApplicationContextAwareProcessor 与我们之前了解的 Aware 接口有关联。

可以看到 ApplicationContextAwareProcessor 一进来，就看到一个很明显的方法：postProcessBeforeInitialization：

```java
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
			return bean;
		}

		AccessControlContext acc = null;

		if (System.getSecurityManager() != null) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareInterfaces(bean);
				return null;
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}

	private void invokeAwareInterfaces(Object bean) {
		if (bean instanceof EnvironmentAware) {
			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
		}
		if (bean instanceof EmbeddedValueResolverAware) {
			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
		}
		if (bean instanceof ResourceLoaderAware) {
			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
		}
		if (bean instanceof ApplicationEventPublisherAware) {
			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
		}
		if (bean instanceof MessageSourceAware) {
			((MessageSourceAware) bean).setMessageSource(this.applicationContext);
		}
		if (bean instanceof ApplicationContextAware) {
			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
		}
	}
```

很明显，postProcessBeforeInitialization 是专门处理这 6个接口的实现类的。

**之前已经讲过，如果一个 bean 实现了感知接口，Spring 容器在实例化 bean 的时候就会调用感知的方法，将 Spring 容器内部的对象注入到感知接口方法中，这样的话，实现了感知接口的bean就可以拿到 Spring的内部对象，就可以对 Spring 容器做自定义改造了。**

`比如说，我们经常要在很多地方用到 Spring 容器，通过容器获取一些 bean。我们就可以让 bean 预先实现 ApplicationContextAware 接口。`

`Spring 在实例化 bean 的时候，就会通过调用 setApplicationContext 方法，将 ApplicationContext 注入到bean中了，这个 bean 获取到 ApplicationContext 之后，容器中所有的 bean 就都可以获取了。`

Spring容器在初始化 bean之前会统一执行所有后置处理器（BeanPostProcessor）的前置（postProcessBeforeInitialization）处理方法。

### 添加需要忽略的感知接口

AbstractApplicationContext#prepareBeanFactory：

```java
// 为 beanFactory 添加需要忽略的感知接口
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
```

简单来说说，如果一个bean实现了传入ignoreDependencyInterface方法的这些感知接口，Spring 是不允许注入任何的依赖到 bean 中的，只允许 Spring 内部调用感知接口来注入相应的依赖。

### 添加指定接口的依赖

```java
// 为 beanFactory 注册指定接口的依赖实现类
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```

#### 为什么要为这些接口指定依赖呢？

目的也很简单，如果要从 Spring 容器中获取一个 bean，如果这个 bean实现的接口是 BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 中的任何一个，就直接返回方法 registerResolvableDependency 中设置进去的 beanFactory 给你。

`比如：你要从 Spring 容器中获取一个 bean，恰好这个 bean 实现了接口 ApplicationContext，此时就算你自己写了一个实现ApplicationContext接口的类注入到 Spring容器中，Spring 最终也会忽略掉你写的那个 bean，而使用方法registerResolvableDependency中设置进去的 beanFactory 给你。`

**这样的话，Spring 就可以保证 Spring 中一些关键的接口，它们实现类只能是 Spring 内部指定的一些对象了。**

## 17-Spring高级容器初始化：BeanFactoryPostProcessor是什么呢

### 空实现的工厂后处理方法

AbstractApplicationContext#refresh：

```java
// 空实现，留给子类去拓展实现
// 用于注册特殊的后处理器来加载特殊的一些bean
postProcessBeanFactory(beanFactory);
```

```java
/**
 * 在ApplicationContext 初始化完成后，可以通过该方法来修改 ApplicationContext的beanFactory
 * 因为这个时候，所有bean的BeanDefinition，已经加载到了 beanFactory容器中了，但是这些bean都还没有实例
 * 化，可以通过该方法注册一些后处理器来修改bean的信息
 */
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
}
```

可以看到 postProcessBeanFactory 是一个空实现，是由 protected 关键字修饰的，毫无疑问，该方法也是 Spring 提供给我们的一个扩展点。

bean 的实例化说白了就是创建一个bean对象，触发实例化最常见的一个场景就是我们直接调用容器的getBean方法，这个时候，Spring就会获取容器中的BeanDefinition，利用BeanDefinition中的各种属性值去创建一个bean出来，这个过程就是bean的实例化。

### 自定义空实现工厂后处理方法

见 /Users/lyf/Workspace/www/blog-demo/spring-demo/src/test/java/com/fullstackboy/springdemo/bean/AwareTest.java

### BeanFactoryPostProcessor是什么呢

```java
// 执行 beanFactory，即Spring容器级别的后处理器
invokeBeanFactoryPostProcessors(beanFactory);
```

```java
@FunctionalInterface
public interface BeanFactoryPostProcessor {

	/**
	 * 在ApplicationContext初始化完成后，可以通过该方法来修改ApplicationContext内部的beanFactory
	 * 因为这个时候所有的beanDefinition，已经加载到了beanFactory中，但这些bean都还没有实例化。
	 * 允许我们覆盖该方法，修改beanDefinition。
	 * @param beanFactory the bean factory used by the application context
	 * @throws org.springframework.beans.BeansException in case of errors
	 */
	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
```

可以看到，BeanFactoryPostProcessor#postProcessBeanFactory 和我们之前看的AbstractApplicationContext#postProcessBeanFactory 一样，都是空实现，也就是给了我们一次机会，允许我们通过beanFactory去获取相应的BeanDefinition并修改相应的信息。

### 自定义BeanFactoryPostProcessor

但是和刚才实现的postProcessBeanFactory方法稍微有些不同的，就是需要额外实现 BeanFactoryPostProcessor 接口。

详见 /Users/lyf/Workspace/www/blog-demo/spring-demo/src/test/java/com/fullstackboy/springdemo/MyBeanFactoryPostProcessorDemo.java

看到这里，大家心里可能会有一个疑惑：

既然我们在refresh方法中就可以通过继承 空实现方法postProcessBeanFactory来修改beanFactory容器级别的信息，Spring 为什么还要给我们提供 BeanFactoryPostProcessor 呢？

个人觉得，如果我们要修改 beanFactory 中的很多种信息，而且每种修改操作的逻辑都非常的复杂，这些逻辑势必会耦合在一个方法中，这样也不太好。

现在有了 BeanFactoryPostProcessor 接口之后，我们可以为每种修改操作分别创建一个类实现接口 BeanFactoryPostProcessor，这样的话至少在代码上是解耦的。

## 18-Spring高级容器初始化：BeanFactoryPostProcessor如何执行

基本上是源码层面，太细化：https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_620dcd5de4b054255d9ec084/1?from=p_620dbc7de4b04d7e2fcca5a0&type=6&parent_pro_id=

## 19-Spring高级容器初始化：BeanPostProcessor是如何注册的呢？

## 初始 BeanPostProcessor

AbstractApplicationContext#refresh：

```java
// 在 Spring 容器中，注册 bean 的后处理器
registerBeanPostProcessors(beanFactory);	
```



在Spring框架中，BeanPostProcessor的postProcessBeforeInitialization、postProcessAfterInitialization的执行调用链如下：

```bash
AbstractAutowireCapableBeanFactory#doCreateBean：
会先实例化bean：
instanceWrapper = createBeanInstance(beanName, mbd, args);
然后后边再执行初始化bean：
exposedObject = initializeBean(beanName, exposedObject, mbd);


AbstractAutowireCapableBeanFactory#initializeBean
  -> applyBeanPostProcessorsBeforeInitialization()
  -> postProcessBeforeInitialization()
执行完：invokeInitMethods(beanName, wrappedBean, mbd)后，再执行：
applyBeanPostProcessorsAfterInitialization()
   -> postProcessAfterInitialization()  
```

会在 bean 实例化和依赖注入完毕后，分别在 bean实例化前、bean实例化后执行 postProcessBeforeInitialization、postProcessAfterInitialization。我们可以在这里加上自己的逻辑，比如去修改beanDefinition的属性信息。

关于 BeanPostProcessor 的demo见：

/Users/lyf/Workspace/www/blog-demo/spring-demo/src/test/java/com/fullstackboy/springdemo/UserPostProcessorDemo.java

## BeanPostProcessor的注册

## 20-Spring高级容器初始化：Spring是如何基于事件驱动的呢？

### 初始化消息源MessageSource

AbstractApplicationContext#refresh：

```java
// 在Spring容器中，初始化消息源MessageSource
initMessageSource();
```

Spring的MessageSource是用来处理国际化的，那什么是国际化呢？

比如一段文字，在不同的国家肯定使用不同的语言来显示的。

对于我们系统而言，就需要根据当前系统选择的国家地区，用相应的文字来显示。

但是，在日常开发中，对于使用Spring的MessageSource来支持国际化的场景已经是很少了，所以这里暂时不再过多的探讨。

### 初始化广播器ApplicationEventMulticaster

```java
// 初始化广播器
initApplicationEventMulticaster();
```

**如果容器中存在 "applicationEventMulticaster" 这个bean，则直接取出来，赋给applicationEventMulticaster；**

**如果容器中不存在 "applicationEventMulticaster" 这个bean，则直接创建一个SimpleApplicationEventMulticaster类型的对象，并设置到Spring容器beanFactory中。**

ApplicationEventMulticaster 是事件广播器，与它息息相关的是 ApplicationListener。

在Spring中，广播器 ApplicationEventMulticaster 可以注册多个事件监听器 ApplicationListener，当特定的事件 ApplicationListener 发生时，就会触发广播器 ApplicationEventMulticaster 来遍历各个 ApplicationListener 中的方法，看下到底是哪个负责监听的事件发生了，让指定的监听器来处理。

接下来，我们通过一个案例来看下在Spring中，是如何通过广播器和监听器来完成功能的。

### 如何基于Spring内部广播器发布事件

demo 见 /Users/lyf/Workspace/www/blog-demo/spring-demo/src/test/java/EventDemo.java

可以看到当 ClassPathXmlApplicationContext 初始化完成后，可以通过调用ClassPathXmlApplicationContext#publishEvent方法，触发我们定义好的事件。

### Spring中事件是如何发布的呢？

调用链：

```java
AbstractApplicationContext#publishEvent
->
SimpleApplicationEventMulticaster#multicastEvent
->
SimpleApplicationEventMulticaster#invokeListener
  -> doInvokeListener()

  ->  
private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
        try {
            listener.onApplicationEvent(event);
        } catch (ClassCastException var6) {
            String msg = var6.getMessage();
            if (msg != null && !this.matchesClassCastMessage(msg, event.getClass())) {
                throw var6;
            }

            Log logger = LogFactory.getLog(this.getClass());
            if (logger.isTraceEnabled()) {
                logger.trace("Non-matching event type for listener: " + listener, var6);
            }
        }

    }  
```

看到这里大家就会明白了，最终会调用监听器里的 onApplicationEvent 方法执行监听器中的逻辑。

`因为目前只要我们自定义的监听器MyListener 会处理自定义事件 MyEvent，所以就算其它的监听器执行了onApplicationEvent 方法，也会选择无视这个事件。`

Spring 的这套基于事件驱动的机制，主要就是通过广播器ApplicationEventMulticaster 和监听器 ApplicationListener 来实现的，大家也可以理解为发布-订阅模式。

- ApplicationEventMulticaster 用来发布事件；
- ApplicationListener 监听订阅事件，每种监听器负责处理一个或多个事件。

而且如果大家冷静的分析一下，Spring的这套发布订阅的模式，采用的就是设计模式中的**观察者模式**。

- ApplicationEventMulticaster 做为广播事件的subject，属于被观察者；
- ApplicationListener 做为Observer 观察者，最终用来处理相应事件的，属于观察者 Observer。