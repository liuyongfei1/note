# 手把手带你吃透Spring框架核心源码

## 备注

主要笔记来自 儒猿技术窝：https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_620dbc7de4b04d7e2fcca5a0/6

在学习的时候可以结合 <<手撸Spring>>* 小傅哥.pdf 及学习笔记一块学习。https://github.com/fuzhengwei/small-spring

## 03-Resource 到底是个什么玩意儿

### 初始ClassPathResource

从 ClassPathResource 加载 applicationContext.xml 开始，了解下 ClassPathResource 是什么。

ClassPathResource 其实就是一个实现了 Resource 接口的实现类而已。和 ClassPathResource 类似的还有 UrlResource、FileSystemResource 和 InputStreamResource，它们都实现了 Resource 接口，而 Resource 接口又实现了 InputStreamSource 接口。

### Resource和InputStreamSource

首先，我们来回答第一个问题：什么是 Resource 接口？ =》`Spring 统一把所有使用到的资源都抽象成了 Resource，不同来源的资源对应着不同的 Resource 实现类。`

我们可以来看一下 Resource 接口中，都有哪些方法：

<img src="1.assets/image-20220309133257298.png" alt="image-20220309133257298" style="zoom:50%;" />

再来看看 InputStreamSource 接口是什么呢？

<img src="1.assets/image-20220309133427559.png" alt="image-20220309133427559" style="zoom:50%;" />

可以看到 InputStreamSource 接口中只有一个方法 getInputStream，而且方法返回的就是要给输入流 InputStream。

这也就意味着所有资源只要封装成了Resource，就可以通过调用 InputStreamResource 中的 getInputStream方法，获取资源对应的输入流 InputStream 了。

### 各种Resource是如何加载资源的呢？

ClassPathResource：

```java
public class ClassPathResource implements Resource {

    private final String path;

    private ClassLoader classLoader;

    public ClassPathResource(String path) {
        this(path, (ClassLoader) null);
    }

    public ClassPathResource(String path, ClassLoader classLoader) {
        Assert.notNull(path, "Path must not be null");
        this.path = path;
        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
    }

    @Override
    public InputStream getInputStream() throws IOException {
        InputStream is = classLoader.getResourceAsStream(path);
        if (is == null) {
            throw new FileNotFoundException(
                    this.path + " cannot be opened because it does not exist");
        }
        return is;
    }
}
```

就是通过 classLoader 的底层方法来加载的，没什么特别的地方。

FileSystemResource：

```java
public class FileSystemResource implements Resource {

    private final File file;

    private final String path;

    public FileSystemResource(File file) {
        this.file = file;
        this.path = file.getPath();
    }

    public FileSystemResource(String path) {
        this.file = new File(path);
        this.path = path;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return new FileInputStream(this.file);
    }

    public final String getPath() {
        return this.path;
    }

}
```

更简单，无非是通过 JDK 底层方法，根据文件的路径去加载资源的 InputStrean。

UrlResource：

```java
public class UrlResource implements Resource{

    private final URL url;

    public UrlResource(URL url) {
        Assert.notNull(url,"URL must not be null");
        this.url = url;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        URLConnection con = this.url.openConnection();
        try {
            return con.getInputStream();
        }
        catch (IOException ex){
            if (con instanceof HttpURLConnection){
                ((HttpURLConnection) con).disconnect();
            }
            throw ex;
        }
    }

}
```

通过对应 URL 连接去获取 InputStream。

## 04-Spring初级容器初始化：忽略指定接口自动装配功能

单元测试代码：

```java
XmlBeanFactory beanFactory= new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
Bean1 bean1 = (Bean1) beanFactory.getBean("bean1");
System.out.println(bean1);
```

### 初探ignoreDependencyInterface方法

1、XmlBeanFactory构造函数：

```java
/**
	 * Create a new XmlBeanFactory with the given resource,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource) throws BeansException {
		this(resource, null);
	}

	/**
	 * Create a new XmlBeanFactory with the given input stream,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @param parentBeanFactory parent bean factory
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
		this.reader.loadBeanDefinitions(resource);
	}
```

2、先来看父类构造函数干了些什么：

```java
/**
	 * Create a new AbstractAutowireCapableBeanFactory.
	 */
	public AbstractAutowireCapableBeanFactory() {
		super();
		ignoreDependencyInterface(BeanNameAware.class);
		ignoreDependencyInterface(BeanFactoryAware.class);
		ignoreDependencyInterface(BeanClassLoaderAware.class);
	}
```

### ignoreDependencyInterface方法是干什么的呢

```java
public void ignoreDependencyInterface(Class<?> ifc) {
  this.ignoredDependencyInterfaces.add(ifc);
}
```

ignoredDependencyInterfaces 就是个 Set 集合，也就是将这三个 Aware 放入 Set 集合。

搜了一下代码，ignoredDependencyInterfaces 只在 isExcludedFromDependencyCheck的方法中用到了：

```java
/**
	 * Determine whether the given bean property is excluded from dependency checks.
	 * <p>This implementation excludes properties defined by CGLIB and
	 * properties whose type matches an ignored dependency type or which
	 * are defined by an ignored dependency interface.
	 * @param pd the PropertyDescriptor of the bean property
	 * @return whether the bean property is excluded
	 * @see #ignoreDependencyType(Class)
	 * @see #ignoreDependencyInterface(Class)
	 */
	protected boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {
		return (AutowireUtils.isExcludedFromDependencyCheck(pd) ||
				this.ignoredDependencyTypes.contains(pd.getPropertyType()) ||
				AutowireUtils.isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));
}
```

根据这个方法的注释可以知道，这个方法的作用就是明确一个bean的属性是否要从依赖检查中排除掉。

```java
/**
 * Return whether the setter method of the given bean property is defined
 * in any of the given interfaces.
 * @param pd the PropertyDescriptor of the bean property
 * @param interfaces the Set of interfaces (Class objects)
 * @return whether the setter method is defined by an interface
 */
public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {
   Method setter = pd.getWriteMethod();
   if (setter != null) {
      Class<?> targetClass = setter.getDeclaringClass();
      for (Class<?> ifc : interfaces) {
         // 判断属性所在的类，是否实现了这些Aware接口
         // 并且在这些感知接口中，是否也存在相同的setter方法
         if (ifc.isAssignableFrom(targetClass) && ClassUtils.hasMethod(ifc, setter)) {
            return true;
         }
      }
   }
   return false;
}
```

这个方法主要判断两点：

- 一是bean的属性对应的类，是否实现了 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware的某个接口；
- 二是这个bean属性对应的setter方法，在这三个感知接口中是否也存在相同的方法。

如果同时满足这两点，方法 isSetterDefinedInInterface 就会返回true，Spring 在自动装配时也就是在创建这个bean时，就不会给该属性注入值了。

来看这个demo，可能会更容易理解：

src/test/java/com/fullstackboy/springdemo/bean/AwareTest.java

我们从输出结果中可以看出：

就算在 xml 中为属性设置了值，最终也不能注入到 bean 的属性 beanName 中。

而这个结果，其实就是 Spring 内部调用了 BeanNameAware 接口的 setBeanName 方法，为 User2 设置了 beanName 属性的值。

`分析到这里其实已经真相大白了，也就是说如果一个 bean 实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware的某个接口的话，那个 bean 中的属性值如果想要通过 Spring 进行自动装配赋值的话，这个属性对应的 setter 方法，就不能和 感知接口中的方法相同。`

如果相同的话，Spring 就不会为给属性自动装配赋值，而是让 Spring 内部自动调用这些感知接口的方法，来为这些属性赋值。

- 这也是这些感知接口存在的意义了，毕竟，bean 都实现了这些感知接口了，而感知接口恰好已经通过方法 ignoreDependencyInterface 添加到忽略感知接口的集合中了，这就相当于这些属性的赋值权利交给 Spring 内部来决定了。

- Spring 这样设计其实也有一定的合理性了，比如你实现了 BeanNameAware 接口，对应的 beanName 属性的值，当然是这个 bean 在 Spring 容器中的名称啊。

- 此时，如果你从外部的 xml 或注解中注入了一个其它的名称，Spring 理所应当就会忽略掉这个外来值的自动装配了，确保 bean 名称的唯一性。

### Spring中的感知接口又是什么呢

<img src="1.assets/image-20220310091858457.png" alt="image-20220310091858457" style="zoom:50%;" />

`当bean实现了这些感知接口时，Spring 在实例化这些 bean 的时候，就会调用感知接口中的方法，注入相应的数据。`

我们用一个例子来演示一下，这个感知接口有什么用？

src/test/java/com/fullstackboy/springdemo/bean/AopTest.java

## 05-Spring初级容器初始化：基础数据的准备

1、再回到 XmlBeanFactory 的构造函数中：

```java
/**
	 * Create a new XmlBeanFactory with the given input stream,
	 * which must be parsable using DOM.
	 * @param resource the XML resource to load bean definitions from
	 * @param parentBeanFactory parent bean factory
	 * @throws BeansException in case of loading or parsing errors
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
		this.reader.loadBeanDefinitions(resource);
	}
```

### EncodedResource是什么呢

2、XmlBeanDefinitionReader#loadBeanDefinitions

```java
@Override
	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		return loadBeanDefinitions(new EncodedResource(resource));
	}
```

3、EncodedResource

```java
public EncodedResource(Resource resource) {
  this(resource, null, null);
}

private EncodedResource(Resource resource, @Nullable String encoding, @Nullable Charset charset) {
  super();
  Assert.notNull(resource, "Resource must not be null");
  this.resource = resource;
  this.encoding = encoding;
  this.charset = charset;
}
```

在 EncodedResource 类中，使用到 encoding 和 charset 的地方也就一个地方，getReader 方法：

```java
public Reader getReader() throws IOException {
  if (this.charset != null) {
    return new InputStreamReader(this.resource.getInputStream(), this.charset);
  }
  else if (this.encoding != null) {
    return new InputStreamReader(this.resource.getInputStream(), this.encoding);
  }
  else {
    return new InputStreamReader(this.resource.getInputStream());
  }
}
```

可以看到在getReader中：

- 首先会通过getInputStream 方法获取 resource 的输入流，同时会执行字符集或编码，但是现在我们传入的charset和encoding都为null，所以创建的就是一个没有指定字符集和编码的 InputStreamReader；
- InputStreamReader 大家多少都会了解一点，就是 Java SE IO 流中将字节输入流转换为字符输入流的 API，很明显接下来 Spring 将以字符输入流，读取我们的资源Resource。
  - 字符输入流：FileReader 和 BufferedReader；
  - 字符输出流：FileWriter 和 BufferedWriter；
  - FileReader 类仅仅是 InputStreamReader 类的衍生类并未扩展任何功能；
  - `FileReader 类读取数据实质就是 InputStreamReader 类在读取`，而 InputStreamReader 读取实际是 StreamDecoder 类读取。

### 基础数据的准备工作

了解了 EncodedResource 之后，我们再继续回到刚才的位置，查看 XmlBeanDefinitionReader#loadBeanDefinitions方法：

```java
@Override
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
  return loadBeanDefinitions(new EncodedResource(resource));
}

public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
  Assert.notNull(encodedResource, "EncodedResource must not be null");
  if (logger.isTraceEnabled()) {
    logger.trace("Loading XML bean definitions from " + encodedResource);
  }

  Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();

  if (!currentResources.add(encodedResource)) {
    throw new BeanDefinitionStoreException(
      "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
  }
	
  // 获取 encodedResource的输入流
  try (InputStream inputStream = encodedResource.getResource().getInputStream()) {
    // 通过输入流来构建InputResource，并设置响应的编码
    InputSource inputSource = new InputSource(inputStream);
    if (encodedResource.getEncoding() != null) {
      inputSource.setEncoding(encodedResource.getEncoding());
    }
    // 正式开始加载资源
    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
  }
  catch (IOException ex) {
    throw new BeanDefinitionStoreException(
      "IOException parsing XML document from " + encodedResource.getResource(), ex);
  }
  finally {
    currentResources.remove(encodedResource);
    if (currentResources.isEmpty()) {
      this.resourcesCurrentlyBeingLoaded.remove();
    }
  }
}
```

到这一步，数据准备的工作才算完成，从 doLoadBeanDefinitions 开始就要正式解析 Xml 配置文件了。

## 06-Spring初级容器初始化：加载XML的Document

### Spring是如何解析XML的

XmlBeanDefinitionReader：

```java
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
      // 根据输入流和 resource，创建xml文件对应的Documnet
			Document doc = doLoadDocument(inputSource, resource);
      // 解析Document，并注册bean到Spring容器中
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug("Loaded " + count + " bean definitions from " + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					"Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					"XML document from " + resource + " is invalid", ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"Parser configuration exception parsing XML from " + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"IOException parsing XML document from " + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					"Unexpected exception parsing XML document from " + resource, ex);
		}
	}
```

doLoadDocument -》loadDocument

DefaultDocumentLoader#loadDocument

```java
/**
	 * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
	 * XML parser.
	 */
	@Override
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
		}
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		return builder.parse(inputSource);
	}
```

看到这里几乎就真相大白了，Spring其实是通过 DOM 来解析XML文件的。