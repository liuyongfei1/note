### StringBuilder和StringBuffer区别

#### 区别一：线程安全

StringBuffer：线程安全，因为StringBuffer的所有公开方法都是synchronized修饰的，而StringBuilder并没有synchronized修饰。

#### 区别二：缓存区

StringBuilder代码段：

```java
@Override
public String toString() {
  // Create a copy,don't share the array
  return new String(value,0,count);
}
```

StringBuffer代码段：

```java
private transient char[] toStringCache;
 
@Override
    public synchronized String toString() {
        if (toStringCache == null) {
            toStringCache = Arrays.copyOfRange(value, 0, count);
        }
        return new String(toStringCache, true);
    }
```

可以看出，StringBuffer每次获取toString都会直接使用缓存区的toStringCache值来构造一个字符串。

而StringBuilder则每次都需要复制一个字符串，再构造一个字符串。

#### 区别三：性能

既然StringBuffer是线程安全的，他的所有公开方法都是同步的，StringBuilder是没有对方法加锁同步的，所以StringBuilder的性能要远大于StringBuffer。

#### 总结

StringBuffer是线程安全的，适用于在多线程操作；单线程场合则StringBuilder更适合。



### 开发一个提供给别人使用的SDK?

### Restful的 PUT与POST区别？

例如，eshop项目里，ScheduleApi 里的那些请求为什么都用PUT接收？

PUT和POST都可以创建和修改资源，它们的区别是什么？

- 在更新资源时，PUT和POST基本相同；
- 在创建资源时，PUT可以指定资源路径，POST无法指定资源路径。

比如：

/user/create，每次调用它都会新建一个用户，这时可以用POST；

/user/update/{id}，PUT方法更加关心一个具体资源对应的URI，比如更新当前用户信息，这里可以用PUT。

当以更新的形式来修改某一具体资源时，如何判断用PUT还是POST呢？

很简单，如果该更新对应的URI多次调用的结果一致，则PUT:

比如：更新用户信息接口，/user/update/{id}，每次更新提交相同内容时，结果都一致，则用PUT；

每次更新提交相同内容最终的结果不一致时，则用POST。

举个常见的例子，一个接口的功能是将当前余额减一个值，每次提交该值为100，接口如下：

/amount/deduction，调用一次，你的余额-100，调用两次，余额-200，这个时候就用POST。



### ORM

#### 什么是ORM

对象关系映射。

Object：就是 javaBean；

Relational：关系，二维表，数据库中的表；

Mapping：映射，对象中的属性 与表中的字段存在对应关系。

#### 主流的ORM框架

- JPA：Java Persistence API，JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系（只有接口规范）；
- Hibernate： 最流行额ORM框架，通过对象-关系映射配置，可以完全脱离底层SQL;
- Mybatis：apache的一个开源项目iBatis，支持SQL查询，存储过程和高级映射的优秀持久层框架；
- Apache DBUtils，Spring JDBCTemplate。

##### Hibernate编写流程概要

1. 创建数据库和表；
2. 导入hibernate的jar包；
3. 编写核心配置文件hibernate.cfg.xml，配置获得数据源链接、隐射文件等参数；
4. 编写映射文件 hibernate mapping （*.hbm.xml）;
5. 使用api测试。

详见：https://blog.csdn.net/uotail/article/details/81813210