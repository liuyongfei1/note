### StringBuilder和StringBuffer区别

#### 区别一：线程安全

StringBuffer：线程安全，因为StringBuffer的所有公开方法都是synchronized修饰的，而StringBuilder并没有synchronized修饰。

#### 区别二：缓存区

StringBuilder代码段：

```java
@Override
public String toString() {
  // Create a copy,don't share the array
  return new String(value,0,count);
}
```

StringBuffer代码段：

```java
private transient char[] toStringCache;
 
@Override
    public synchronized String toString() {
        if (toStringCache == null) {
            toStringCache = Arrays.copyOfRange(value, 0, count);
        }
        return new String(toStringCache, true);
    }
```

可以看出，StringBuffer每次获取toString都会直接使用缓存区的toStringCache值来构造一个字符串。

而StringBuilder则每次都需要复制一个字符串，再构造一个字符串。

#### 区别三：性能

既然StringBuffer是线程安全的，他的所有公开方法都是同步的，StringBuilder是没有对方法加锁同步的，所以StringBuilder的性能要远大于StringBuffer。

#### 总结

StringBuffer是线程安全的，适用于在多线程操作；单线程场合则StringBuilder更适合。



### 开发一个提供给别人使用的SDK?

### Restful的 PUT与POST区别？

例如，eshop项目里，ScheduleApi 里的那些请求为什么都用PUT接收？

PUT和POST都可以创建和修改资源，它们的区别是什么？

- 在更新资源时，PUT和POST基本相同；
- 在创建资源时，PUT可以指定资源路径，POST无法指定资源路径。

比如：

/user/create，每次调用它都会新建一个用户，这时可以用POST；

/user/update/{id}，PUT方法更加关心一个具体资源对应的URI，比如更新当前用户信息，这里可以用PUT。

当以更新的形式来修改某一具体资源时，如何判断用PUT还是POST呢？

很简单，如果该更新对应的URI多次调用的结果一致，则PUT:

比如：更新用户信息接口，/user/update/{id}，每次更新提交相同内容时，结果都一致，则用PUT；

每次更新提交相同内容最终的结果不一致时，则用POST。

举个常见的例子，一个接口的功能是将当前余额减一个值，每次提交该值为100，接口如下：

/amount/deduction，调用一次，你的余额-100，调用两次，余额-200，这个时候就用POST。



### ORM

#### 什么是ORM

对象关系映射。

Object：就是 javaBean；

Relational：关系，二维表，数据库中的表；

Mapping：映射，对象中的属性 与表中的字段存在对应关系。

#### 主流的ORM框架

- JPA：Java Persistence API，JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系（只有接口规范）；
- Hibernate： 最流行额ORM框架，通过对象-关系映射配置，可以完全脱离底层SQL;
- Mybatis：apache的一个开源项目iBatis，支持SQL查询，存储过程和高级映射的优秀持久层框架；
- Apache DBUtils，Spring JDBCTemplate。

##### Hibernate编写流程概要

1. 创建数据库和表；
2. 导入hibernate的jar包；
3. 编写核心配置文件hibernate.cfg.xml，配置获得数据源链接、隐射文件等参数；
4. 编写映射文件 hibernate mapping （*.hbm.xml）;
5. 使用api测试。

详见：https://blog.csdn.net/uotail/article/details/81813210



#### k8s

一句话说：就是管理docker容器的一个玩意。

具体的说：能把n个docker容器组装到一起，打包弄成一个整体俗称pod，然后可以在各个物理节点上创建这个pod。

其实对于这个pod，k8s可以进行弹性伸缩，只需简单配制一下就能创建n个一摸一样的pod；也可以对这n个pod进行负载均衡，也可以对这n个pod的运行资源进行限制比如每个pod限制几个cpu多少的内存等等。

#### 线上CPU 100%后，怎么解决

找到是哪个进程后，再找出这个进程里边占用最高的那个线程，拿出进程之后就转换为16进制的一个，然后再用jstack，打出它具体的堆栈，定位到具体的哪一行代码

1、找出占用CPU最高的进程

执行top -c，按P，按照 CPU占用率排序：

<img src="面试题.assets/image-20220329201407801.png" alt="image-20220329201407801" style="zoom:50%;" />

2、找出这个进程占用CPU最高的线程

top -Hp 30120

这个显示的pid是十进制的，需要转化为 十六进制。

3、导出进程快照

jstack -l 3033 > ./3033.stack

4、执行grep命令，看那个线程做了什么

```bash
cat 3033.stack |grep 'bda' -C 8
```

从而定位到问题。

详细参考：https://www.cnblogs.com/xichji/p/11713300.html



Mysql

Redis的集群

Dubbo的调用链路

常用的设计模式

分布式锁

Spring Cloud、 bus