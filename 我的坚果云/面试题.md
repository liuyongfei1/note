### StringBuilder和StringBuffer区别

#### 区别一：线程安全

StringBuffer：线程安全，因为StringBuffer的所有公开方法都是synchronized修饰的，而StringBuilder并没有synchronized修饰。

#### 区别二：缓存区

StringBuilder代码段：

```java
@Override
public String toString() {
  // Create a copy,don't share the array
  return new String(value,0,count);
}
```

StringBuffer代码段：

```java
private transient char[] toStringCache;
 
@Override
    public synchronized String toString() {
        if (toStringCache == null) {
            toStringCache = Arrays.copyOfRange(value, 0, count);
        }
        return new String(toStringCache, true);
    }
```

可以看出，StringBuffer每次获取toString都会直接使用缓存区的toStringCache值来构造一个字符串。

而StringBuilder则每次都需要复制一个字符串，再构造一个字符串。

#### 区别三：性能

既然StringBuffer是线程安全的，他的所有公开方法都是同步的，StringBuilder是没有对方法加锁同步的，所以StringBuilder的性能要远大于StringBuffer。

#### 总结

StringBuffer是线程安全的，适用于在多线程操作；单线程场合则StringBuilder更适合。



### 开发一个提供给别人使用的SDK?

### Restful的 PUT与POST区别？

例如，eshop项目里，ScheduleApi 里的那些请求为什么都用PUT接收？

PUT和POST都可以创建和修改资源，它们的区别是什么？

- 在更新资源时，PUT和POST基本相同；
- 在创建资源时，PUT可以指定资源路径，POST无法指定资源路径。

比如：

/user/create，每次调用它都会新建一个用户，这时可以用POST；

/user/update/{id}，PUT方法更加关心一个具体资源对应的URI，比如更新当前用户信息，这里可以用PUT。

当以更新的形式来修改某一具体资源时，如何判断用PUT还是POST呢？

很简单，如果该更新对应的URI多次调用的结果一致，则PUT:

比如：更新用户信息接口，/user/update/{id}，每次更新提交相同内容时，结果都一致，则用PUT；

每次更新提交相同内容最终的结果不一致时，则用POST。

举个常见的例子，一个接口的功能是将当前余额减一个值，每次提交该值为100，接口如下：

/amount/deduction，调用一次，你的余额-100，调用两次，余额-200，这个时候就用POST。



### ORM

#### 什么是ORM

对象关系映射。

Object：就是 javaBean；

Relational：关系，二维表，数据库中的表；

Mapping：映射，对象中的属性 与表中的字段存在对应关系。

#### 主流的ORM框架

- JPA：Java Persistence API，JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系（只有接口规范）；
- Hibernate： 最流行额ORM框架，通过对象-关系映射配置，可以完全脱离底层SQL;
- Mybatis：apache的一个开源项目iBatis，支持SQL查询，存储过程和高级映射的优秀持久层框架；
- Apache DBUtils，Spring JDBCTemplate。

##### Hibernate编写流程概要

1. 创建数据库和表；
2. 导入hibernate的jar包；
3. 编写核心配置文件hibernate.cfg.xml，配置获得数据源链接、隐射文件等参数；
4. 编写映射文件 hibernate mapping （*.hbm.xml）;
5. 使用api测试。

详见：https://blog.csdn.net/uotail/article/details/81813210



#### k8s

一句话说：就是管理docker容器的一个玩意。

具体的说：能把n个docker容器组装到一起，打包弄成一个整体俗称pod，然后可以在各个物理节点上创建这个pod。

其实对于这个pod，k8s可以进行弹性伸缩，只需简单配制一下就能创建n个一摸一样的pod；也可以对这n个pod进行负载均衡，也可以对这n个pod的运行资源进行限制比如每个pod限制几个cpu多少的内存等等。

#### 线上CPU 100%后，怎么解决

找到是哪个进程后，再找出这个进程里边占用最高的那个线程，拿出进程之后就转换为16进制的一个，然后再用jstack，打出它具体的堆栈，定位到具体的哪一行代码

1、找出占用CPU最高的进程

执行top -c，按P，按照 CPU占用率排序：

<img src="面试题.assets/image-20220329201407801.png" alt="image-20220329201407801" style="zoom:50%;" />

2、找出这个进程占用CPU最高的线程

top -Hp 30120

这个显示的pid是十进制的，需要转化为 十六进制。

3、导出进程快照

jstack -l 3033 > ./3033.stack

4、执行grep命令，看那个线程做了什么

```bash
cat 3033.stack |grep 'bda' -C 8
```

从而定位到问题。

详细参考：https://www.cnblogs.com/xichji/p/11713300.html



Mysql

Redis的集群

Dubbo的调用链路

常用的设计模式

分布式锁

Spring Cloud、 bus

---------------

需要充电的：

1. java乐观锁和悲观锁的区别

2. synchronized 偏向锁 轻量级锁

    

### Java线程的几种状态

https://blog.csdn.net/xyzyhs/article/details/121417200

- NEW-新建
- RUNNABLE-可运行
- BLOCKED-阻塞
- WAITING-等待
- TIMED_WAITING 等待（有时限）
- TERMINATED-终结

![Java线程状态](面试题.assets/Java线程状态-0013421.png)

### 并发编程系列——wait原理的讨论

https://blog.csdn.net/java_lyvee/article/details/110996764?spm=1001.2014.3001.5501

**synchronized**关键字是倒序唤醒，但是如果你使用**ReentrantLock**那么则是正序唤醒；

状态：没有看。

### redis的线程模型

redis 内部使用文件事件处理器 file event handler。这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。



文件事件分派器从队列中获取socket，交给连接应答处理器。

**连接应答处理器**会创建一个与客户端能够通信的socket01，并将该 socket01 的 AE_READABLE 事件与**命令请求处理器**关联。

假设此时客户端发送了一个 set key value 请求，

redis6.0之后的版本抛弃了单线程模型的这一设计，原本使用单线程运行的redis也开始选择性的使用多线程模型。

redis的多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

### redis的主要数据类型

- String
- Hashes
- Set：无序集合，自动去重。
- Lists
- Sorted Sets

### Redis过期策略

#### 定期删除

#### 惰性删除

#### 内存淘汰机制

allkeys-lru：

当内存不足以容纳新写入的数据时，在键空间中，移除最近最少使用的key（这个是最常用的）。

### Redis如何才能做到高可用

Redis的高可用架构，叫做 failover 故障转移，也可以叫做主备切换。

master node 在故障时，自动检测，并将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了redis的主从架构下的高可用。

### Redis哨兵集群实现高可用

- 集群监控
- 消息通知
- 故障转移
- 配置中心

### 哨兵的核心知识

- 哨兵至少需要3个实例，来保证自己的健壮性；
- 哨兵+Redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性。

### Redis哨兵主备切换的数据丢失问题

- 异步复制导致的数据丢失；
- 脑裂导致的数据丢失

#### 数据丢失问题的解决方案

```bash
min-slave-to-write 1
min-slave-max-tag 10
```

表示，要求至少有1个slave，数据复制和同步的延迟不能超过10秒。

如果说一旦所有的slave，数据复制和同步都超过了10秒，那么这个时候，master就不会再接收任何请求了。

### Redis的持久化有哪几种方式？

#### RDB

#### AOF

#### RDB和AOF到底该如何选择

### 缓存雪崩

缓存雪崩的事前事中事后的解决方案如下：

- 事前：Redis高可用，主从+哨兵，避免全崩溃；
- 事中：本地cache缓存+ hystrix限流&降级，避免mysql被打死；
- 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

### 缓存穿透

假设一秒5000个请求，结果其中4000个请求都是黑客发出的恶意攻击。

黑客发出的那4000个攻击，缓存中查不到，每次你去数据库中里查，也查不到。

解决方式很简单：每次系统A只要从数据中没查到，就写一个空值到缓存里去，比如： set -999 UNKNOW。

然后设置一个过期时间，这样下次有相同的key来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。

### 缓存击穿

就是说某个key非常热点，访问非常频繁，处于集中式高并发访问的情况，当然这个key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库。

不同场景下的解决方式：

- 若缓存的数据基本不会发生更新的，则可尝试将该热点数据设置为永不过期；
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于Redis、zookeeper等分布式中间件的分布式互斥锁，或者本地互斥锁，以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新内存。
- 若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

### 充电

1. 为什么要用jwt？
2. 分布式定时任务框架？Quartz，XXXJob？