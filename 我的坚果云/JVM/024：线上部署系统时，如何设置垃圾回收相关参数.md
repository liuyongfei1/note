## 前文回顾

本文要更加深入的去说一说CMS垃圾回收期间的一些细节问题，同时给出CMS常见的JVM参数应如何设置。

## 1.并发回收垃圾导致CPU资源紧张

CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统工作，但是大家发现没有，在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。

- 并发标记的时候，需要对 GC Roots 进行深度追踪，看所有对象里面到底有多少是存活的。
- 但是因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时比较高。并发清理，又需要把垃圾对象从各种随机的内存位置清理掉，也是比较耗时的。

所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收器线程的数量是：（CPU核数 + 3）/ 4。

我们用最普通的2核4G机器来计算一下，假设是2核CPU，本来CPU资源就有限，结果此时CMS还会有个 （2 + 3）/ 4 = 1 个垃圾回收线程，去占用宝贵的一个CPU。

所以其实CMS这个并发垃圾回收的机制，第一个问题就是会耗CPU资源。

## 2. Corcurrent Mode Failure问题 

这个问题是很多同学都很关注的一个问题，就是如下图：

在并发清理阶段，CMS 只不过是回收之前标记好的垃圾对象。

但是这个阶段系统一直在运行，可能会随着系统运行，让一些对象进入老年代，然后短时间内又没人引用这些对象了，就变成垃圾对象，这种垃圾对象就是老年代的"浮动垃圾"。

因为他虽然成为了垃圾，但是CMS只能回收之前标记出来的垃圾对象，不会回收他们，需要等到下一场GC的时候才能回收他们。

所以为了保证在CMS垃圾回收期间，还有一定的内存空间让一些对象进入老年代，一般会预留一些空间。

CMS 垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就会自动执行 GC。

"-XX:CMSInitiatingOccupancyOnly"参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK1.6里默认的值是 92%。

也就是说老年代占用92%空间了，就会自动进行垃圾回收，预留8%的空间给并发回收期间，系统程序把一些对象放入老年代中。

那么，如果CMS垃圾回收期间，系统程序放入老年代的对象大于了可用内存空间，此时会如何？

这个时候，会发生"Corcurrent Mode Failure"，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。

**此时就会自动用"Serial Old"垃圾回收器替代 CMS，就是直接强行把系统程序"Stop the World"，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新对象产生，然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。**

所以在生产实践中，这个自动触发的CMS垃圾回收的比例需要合理优化一下，避免"Corcurrent Mode Failure"问题。

## 3、内存碎片问题

老年代的CMS采用"标记-清理"算法，每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生。

如果内存碎片太多，会导致后续的对象进入老年代找不到可用的连续内存空间，然后触发Full GC。

CMS有一个参数是："-XX: UseCMSCompactAtFullCollection"，默认就打开了，他意思是在 Full GC之后，会再次进行"Stop the World"，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。

还有一个参数是："-XX:CMSFullGCsBeforeCompaction"，这个意思是执行多少次Full GC之后，再进行一次内存碎片的整理工作，默认是0，意思是每次Full GC之后，都会进行一次内存碎片整理。

