### 类加载器

1、虚拟机自带的加载器； 

2、启动类（根）加载器； =》jre/lib/rt.jar（这个就是根加载器里面的一些东西）

3、扩展类加载器；=》jre/lib/ext 目录下的

4、应用程序加载器。=》 就是我们本地自己写的类（只要实现了抽象的java.lang下的抽象类（ClassLoader））

![类加载器](Untitled.assets/类加载器.png)

### 双亲委派机制

目的是：安全性考虑。

当前 --》 EXT --》BOOT

1. 类加载器收到类加载的请求；
2. 将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器（Boot）；
3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载；
4. 重复步骤3。

```java
package java.lang;

/**
 * 举例讲双亲委派机制
 *
 * 这个String跟java管理的是同包同名
 * 
 * @author Liuyongfei
 * @date 2021/12/26 22:31
 */
public class String {

    public String toString() {
        return "Hello";
    }

    public static void main(String[] args) {
        String s = new String();
        System.out.println(s.toString());
    }
}
```

<img src="1.assets/image-20211226223816329.png" alt="image-20211226223816329" style="zoom:50%;" />

说这个String里找不到main方法，但明明我们这个类里边有main方法呢？

所以可以说明程序是没有执行这个类的。为什么？

双亲委派机制=》为了安全。

#### 原理

在运行一个类之前，会一级一级向上找。从 APP -》EXT =》BOOT。

- 这个例子中，我们是 new String()，会在当前找，有这个String类，然后会再往 EXT里找，最后再往BOOT里找。

- 最终会执行BOOT里的String类。