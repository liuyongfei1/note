## ConcurrentHashMap

ConcurrentHashMap底层就是基于数组，可能会扩容，中间都是有锁的，分段加锁。读的时候通过volatile读保证读到最新的数据。

分段加锁，将一份数据拆分为多个segment，对每个segment设置一把小锁。比如put操作，仅仅是锁定一个segment而已，锁一部分的数据，其它的线程操作其它segment的数据，跟你是没有竞争的。

可以提高多线程并发操作hashmap的效率。

### 源码分析

#### put()方法

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

// 使用spread算法，获取到一个hash值
int hash = spread(key.hashCode());

static final int spread(int h) {
        // 相当于是把高低16位都考虑到后面的hash取模算法里，可以降低hash冲突的概率。
        return (h ^ (h >>> 16)) & HASH_BITS;
    }
```

- spread算法，通过高低16位异或的操作，降低hash冲突的概率；
- 然后hash值再跟数组的大小做了一个取模算法，定位到数组的一个位置。

else if ((f = tabAt(tab, i = (n - 1) & hash)) == null)   =》也就是说如果这个位置没有元素的话，就把 key-value 对放进数组的这个位置。

```java
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
}
```

这里使用的是 UnSafe和CAS操作，确保了线程安全性。同一时刻只有一个线程可以把这个 key-value 对放进数组的这个位置上去。

#### 分段加锁

其实这里已经体现了分段加锁的机制，它并没有对整个数组进行synchronized加锁，这样，线程会串行化起来，并发效率会比较低。

`仅仅是对数组的同一个位置的元素赋值的时候，多个线程会基于CAS（隐式的锁），对那个元素进行加锁。`

数组大小是16，有16个元素，同时可以允许最多是16个线程同时并发的来操作这个数组，如果16个线程操作的是数组的不同位置的元素的话，此时16个线程之间是没有任何锁的关系，只有竞争同一个位置的元素的多个线程，才会对一把锁进行争用的操作，大概可以这么来理解。

由于ConcurrentHashMap采用分段加锁，分段的粒度很细，所以并发写的性能是特别好的，并发读是通过volatile读来保证一定读到最新的数据。

#### 链表和红黑树解决hash冲突

如果当前put元素的key跟数组里这个位置的key是一样的，此时就对数据当前位置的value覆盖一下；

如果当前put元素的key跟数组里这个位置的key不一样，就默认走链表的处理，此时 e.next = 新封装的一个节点。

当链表的长度达到一个阈值，比如超过8之后，就会把链表转为红黑树。

转化为红黑树后，下次如果还有hash冲突的问题，是直接把这个key-value对添加到红黑树中去。

#### JDK1.8及以后

又变成了只有一个数组。然后数组里的每一个元素进行put操作的时候，都是有一个不同的锁。

如果两个线程都是要对同一个位置进行put操作，就采取CAS的策略。

如果多个线程对不同位置进行操作这时是没有关系的，如果是对同一个位置进行，如果CAS执行失败了，就表明比如数组[5]这个位置，刚刚已经有别的线程往这个位置放入元素了，**这个时候就需要在这个位置基于链表+红黑树进行处理**。

会采取类似 synchronized(数组[5])这种方式，对数组[5]这个对象进行加锁，然后基于链表或红黑树在这个位置插入自己的数据。

你想想，如果不采用这种方式，而是直接对整个数组加锁，这样就相当于串行，效率会比较低的。

所以JDK1.8以后，就是这种方式：

`如果多个线程对不同位置的元素操作，此时大家是可以并发执行的；如果是对同一个位置的元素进行操作，才会加锁串行化处理。`



#### 案例场景

微服务注册中心的客户端 register-client：

client使用读写锁，大部分情况下都是在读，读锁是可以并发执行的。所以哪怕这个注册表使用的是hashMap也是无所谓的。

server端会频繁的更新map里的某个key,value对，这跟client端是不一样的，最好是使用 ConcurrentHashMap，哪怕多个线程写，它可以保证多线程写的安全。

为了降低读写锁的冲突，这里做了一套缓冲机制。把读写锁碰撞的概率降低了。