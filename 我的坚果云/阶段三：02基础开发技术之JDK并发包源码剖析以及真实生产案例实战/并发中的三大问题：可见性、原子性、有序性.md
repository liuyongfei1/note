### 并发中的三大问题：可见性、原子性、有序性

#### 可见性

A线程修改一个共享的变量，B线程却还一直用的修改前的变量，不能及时感知到。

#### 原子性

共享变量 i=0；

A线程操作 i++，i => 1

B线程操作i++，i => 2

这是我们期望的结果，但实际B线程运行的结果可能还是1。

多线程并发同时写一个变量，就会出现这种问题。结合Java内存模型来理解。

##### 解决办法

使用synchronized加锁，同一时间只能有一个线程获取到锁。

#### 有序性

对于代码，同时还有一个问题是指令排序。

编译器和指令器，有的时候为了提高代码的执行效率，会将指令重排序，比如：

```java
flag = false;

// 线程1
perpare();  // 准备资源
flag = true;

// 线程2
while(!flag) {
	Thread.sleep(1000);
}

execute(); // 基于准备好的资源执行操作

```

重排序之后，让 flag = true 先执行了，结果直接跳过while等待直接执行某段代码了，结果prepare还没执行，就会导致代码逻辑出现异常。

#### volatile指令如何保证有序性

基于happens-before原则来看volatile如何保证原子性。

java中有一个happens-before原则：

编译器、指令器可能对代码重排。只要符合happens-before原则，则代码就不能胡乱重排：

- 程序次序规则
- 锁定规则
- volatile变量规则
- 传递规则
- 线程启动规则等

我们还以上面那段代码来举例：

```java
// 线程1
perpare();  // 准备资源
volatile flag = true;

// 线程2
while(!flag) {
	Thread.sleep(1000);
}

execute(); // 基于准备好的资源执行操作
```

- 如果用volatile来修饰变量，则一定可以让prepare()代码在flag=true之前先执行，这就禁止了指令重排。
- 因为volatile要求的是，它前边的代码一定不能指令重排到它后边，它后边的代码一定不能指令重排到它前边。

