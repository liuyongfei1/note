面试突击的定位

面试突击第一季：

redis连环炮、mq连环炮、网络连环炮、JDK集合连环炮、jvm连环炮、spring源码连环炮、tomcat连环炮、linux连环炮、系统设计连环炮、生产实践连环炮

面试突击第二季：

针对分布式架构这个专题讲，带一点点的小深度。

面试突击第三季：

对于每一个小专题（偏基础），都会挑选几个高频的问题出来进行讲解。

### 07、你知道HaspMap底层的数据结构是什么吗

### 08、JDK1.8中的hash算法和寻址算法是如何优化的？

底层最核心的数据结构就是 数组。

往里边put数据的时候，会根据key算出来一个hash值，根据hash值与Map的长度进行取模（比如长度是16，取模后的值肯定是在0到16之间），然后就会定位到数组的一个元素里去。

最最简单的理解：

<img src="1.assets/image-20220408180459135.png" alt="image-20220408180459135" style="zoom:50%;" />

### 09、你知道HashMap是如何解决hash碰撞的吗

**Java中的hashCode方法就是根据一定的规则，将与对象相关的信息（比如对象的存储地址、对象的字段等）映射成一个数值，这个数值称为散列值。**

异或，两个不一样值就为1。hash算法，右移16位：

<img src="1.assets/image-20220408184331351.png" alt="image-20220408184331351" style="zoom:50%;" />



右移16位，高16位 与 低16位，进行异或。

**意义在哪**

#### hash算法优化

对每个hash值，在他的低16位中，让高低16位都进行了异或，让他的低16位同时保持了高16位的特征，尽量避免一些hash值后续出现冲突，进入数组的同一个位置。

经过这个算法，尽量让高16位和低16位，都参与到了运算，尽量避免后边产生hash冲突。

#### 寻址算法优化

 (n - 1) & hash 的性能会比较高，就跟数学公式那样记着就行了。用与运算替代取模，提升性能。

#### hash冲突

多个key，他们计算出来的hash值，与 n-1 与运算之后，发现定位出来的数组还是同一个位置，这就是hash碰撞、hash冲突了。

这个时候会在这个位置挂一个链表，这个链表里放入多个元素，让多个key-value对同时放在数组的同一个位置里。

get的时候如果发现这个位置挂的是一个链表，那么此时就遍历该链表，从里边找到自己想要的那个key-value对即可。

假设你的链表很长，可能会导致遍历链表性能会比较差，O(n)。

`做了什么优化呢`：

如果链表的长度达到了一定的长度后，就会将链表转换为红黑树，遍历一颗红黑树找一个元素，此时是 O(logn)，性能会比链表高。

### 10、说说HashMap是如何进行扩容的

hashmap底层是一个数组，当这个数组满了之后，他会自动进行扩容，变成一个更大的数组，让你在里面可以放更多的元素。

默认就是2倍扩容，扩容之后要进行rehash，给元素重新分配位置。

比如原来数组的长度是16，数组的长度扩容之后就变为32，会重新对每个hash值进行寻址，也就是用每个hash值跟新数组的 length-1 进行与运算。

举例：

```
n-1：  0000 0000 0000 0000 0000 0000 0001 1111
hash1：1111 1111 1111 1111 0000 1111 0000 0101
&结果： 0000 0000 0000 0000 0000 0000 0000 0101 = 5 (index=5的位置)
```



```
n-1：  0000 0000 0000 0000 0000 0000 0001 1111
hash1：1111 1111 1111 1111 0000 1111 0001 0101
&结果： 0000 0000 0000 0000 0000 0000 0001 0101 = 21 (index=21的位置)
```

判断二进制结果中是否多出1个bit 的1，如果没多，那就是原来的index，如果多了出来，那么就是index + oldCap（原来数组的长度），通过这个方式，就避免了refresh的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高。

**BAT面试官为什么都喜欢问并发编程的问题**

syncronized实现原理、CAS无锁化的原理、AQS是什么、Lock锁、ConcurrentHashMap分段加锁的原理、线程池的原理、java内存模型、volatile、对java并发包有什么了解。

### 12、说说synchronized关键字的底层原理是什么？

可以对对象加锁，也可以对类加锁。

底层原理是跟JVM指令和monitor对象有关。=》详见 阶段三：02基础开发技术之JDK并发包源码剖析以及真实生产案例实战/synchronized学习 笔记。

<img src="1.assets/image-20220409232711892.png" alt="image-20220409232711892" style="zoom:50%;" />

### 13、能聊聊你对CAS的理解以及其底层实现原理可以吗？

cas是原子的，底层会对应着硬件级别的一些类似锁的机制（`使用 cpu 硬件提供的 lock 信号保证其原子性`）。

一次cas只能有一个线程执行成功。

比如线程1执行cas的时候发现旧值是0跟最初读到的值是一样的，说明此时没有别的线程修改过，则累加1。

线程2在执行cas的时候，则发现已经变为1，与最初读到的值不一样了，cas就失败了。于是会重新读取当前值，发现是1，再次尝试累加为2，这个时候已经没有其他线程在执行CAS操作了，会发现旧值跟最初读到的值是一样的，则累加为2成功。

CAS在底层的硬件级别给你保证一定是原子性的，同一时间只有一个线程可以执行cas，先比较再设置。其他线程的CAS同时间执行此时会失败。

### 14、ConcurrentHashMap实现线程安全的底层原理到底是什么？

有多个线程要同时修改一个数据的时候，可能会有线程安全的问题，这个时候可以使用 synchronized 进行加锁 或 CAS 去进行安全的累加，去实现多线程场景下的安全的更新一个数据的效果。

JDK并发包里推出了一个 ConcurrentHashMap，默认实现了线程安全性。

#### JDK1.7及JDK1.7之前

JDK1.7及JDK1.7之前，采用的是分段加锁。因为HashMap的底层还是数组，将一个数组分成多个小的数组，每个小数组都对应一个锁，实现分段加锁。

put多个元素的时候，如果put的元素是属于不同的数组的，则互不影响。

#### JDK1.8以及以后

又变成了只有一个数组。然后数组里的每一个元素进行put操作的时候，都是有一个不同的锁。

如果两个线程都是要对同一个位置进行put操作，就采取CAS的策略。

如果多个线程对不同位置进行操作这时是没有关系的，如果是对同一个位置进行，如果CAS执行失败了，就表明比如数组[5]这个位置，刚刚已经有别的线程往这个位置放入元素了，**这个时候就需要在这个位置基于链表+红黑树进行处理**。

会采取类似 synchronized(数组[5])这种方式，对数组[5]这个对象进行加锁，然后基于链表或红黑树在这个位置插入自己的数据。

你想想，如果不采用这种方式，而是直接对整个数组加锁，这样就相当于串行，效率会比较低的。

所以JDK1.8以后，就是这种方式：

`如果多个线程对不同位置的元素操作，此时大家是可以并发执行的；如果是对同一个位置的元素进行操作，才会加锁串行化处理。`

### 15、你对JDK中的AQS理解吗？AQS的实现原理是什么？

AbstractQueuedSynchronizer，抽象队列同步器

```java
ReentrantLock lock = new ReentrantLock();

// 多个线程过来都尝试对同一个lock进行加锁

lock.lock();

// 代码

lock.unlock;
```



ReentrantLock 底层有个核心的组件就是 AQS：

<img src="1.assets/image-20220411082006002.png" alt="image-20220411082006002" style="zoom:50%;" />

FIFO结构图：

![AQS-FIFO结构图](1.assets/AQS-FIFO结构图.png)

其中：

- state 是用 volatile 修饰的，用来标识是否持有锁，这个锁是乐观锁；
- 如果获取当前同步状态state失败时，会将当前线程及等待信息等构建成一个Node，将Node放到FIFO队列里，同时阻塞当前线程，当线程同步状态state释放时，会把FIFO队列中的首节唤醒，使其获取同步状态state；
- 很多JUC包下的锁都是基于AQS实现的；

#### 总结

- 在AQS中维护着一个FIFO的队列，当线程加锁失败后，则会进入这个队列的队尾，并一直保持着自旋；
- 在队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点，则不断尝试获取同步状态，如果state为0，则表明此时没有其它线程在加锁，则该线程会加锁成功，并退出队列；
- 当线程执行完逻辑后，会更新state为0，并唤醒后续节点。

#### 共享式同步状态过程

共享式与独占式的最主要区别是 同一时刻独占式只能有一个线程获取同步状态，而共享式同一时刻则可以有多个线程获取同步状态。例如：读操作可以有多个线程同时进行，而写操作同一时刻只可以有一个线程运行，其它线程都会被阻塞。

### 16、说说线程池底层工作原理可以吗？

### 17、那你再说说线程池的核心配置参数都是干什么的？平时我们应该怎么用？

<img src="1.assets/image-20220411084408505.png" alt="image-20220411084408505" style="zoom:50%;" />



newFixedThreadPool 举例，这些参数分别是干什么用的？

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

- corePoolSize：核心线程数量，比如设置为 3 个；
- maximumPoolSize：比如设置为 200。当队列中一下子来了很多任务，corePoolSize 这3个线程也还在处理任务，没有空闲的，这时就会再创建新的线程，能创建的最大数量就是这个maximumPoolSize；
- keepAliveTime：比如设置为 60s。当队列中的任务都被处理完毕之后，再等 60s，如果还没有新的任务到来，则会销毁 额外创建的线程；
- BlockingQueue<Runnable> workQueue：设置的队列

如果额外线程也满了，队列也满了，此时还有任务要进来，只能reject 掉，他有几种 reject 策略，可以传入 RejectedExecutionHandler

平时怎么用？

1. 可以让队列设置为无界队列，这样队列就不会满，就不用创建额外线程；
2. 也可以使用有界队列，然后 maximumPoolSize设置为 Integer.MAX_VALUE。

### 18、如果在线程中使用无界阻塞队列会发生什么问题？

比如，假如线程里边会调用远程的服务。那么在远程服务异常的情况下，使用无界阻塞队列，会导致内存飙升。

调用超时，假如有新的任务不断的进来，则队列会变得越来越大，此时会导致内存突然飙升起来，而且还可能导致系统 OOM，内存溢出。

### 19、你知道如果线程池的队列满了之后，会发生什么事情吗？

如果你的线程池这样设置：

- corePoolSize：10；
- maximumPoolSize： Integer.MAX_VALUE；
- ArrayBlockingQueue(200)；

有界队列，可以避免内存溢出。但是在队列满了之后，你要给人家讲清楚后边的原理。

**这时会创建很多额外线程。假设有很多任务，corePoolSize 也满了，这时就会无限制的创建额外线程。**

但是每个线程都有 栈内存，无限制的创建线程 也会导致内存资源耗尽，系统也会崩溃掉。

即使内存没有崩溃，但创建过多的线程也有可能会导致你的cpu负载特别的高。

如果此时将 maximumPoolSize 调小一点，比如调为 200，那么会导致有很多的任务直接就走 拒绝策略被 拒绝掉了。

面试官这样问，其实就是想了解你对线程池的底层原理是否了解。

那么该怎么创建线程池呢？具体得看你的业务系统，比如会不会有瞬间来多个任务，或者每个任务处理时间是否需要很久。

**也可以自定义一个 reject 策略。如果线程池无法创建更多任务了，此时可以把后续的任务信息持久化到磁盘里去，然后后台可以专门启动一个线程，等待你的线程池工作负载降低了，他可以慢慢的从磁盘里读取之前持久化的任务，重新提交到线程池里去。**

### 20、如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？

会必然导致线程池里积压的任务 实际上都会丢失的。

**那怎么解决这个问题呢？**

1. 如果你要提交任务到线程池里去，那么在提交任务到线程池里去之前，麻烦你先在数据库里插入这个任务信息，同时设置一个状态字段：未提交、已提交、提交成功。

2. 然后，搞一个后台线程，扫描数据库里 未提交和已提交的任务信息，重新提交到线程池里去。

3. 这个时候，如果机器突然宕机，然后系统重启后，后台线程处理这个逻辑就行了。

### 21、谈谈你对Java内存模型的理解可以吗？

<img src="1.assets/image-20220411140652594.png" alt="image-20220411140652594" style="zoom:50%;" />



多个线程同时操作一个内存中的变量，需要经过 read、load、use、aggign、store、write 六个指令。

Java内存模型，多线程并发时的一个工作流程原理。

我们会发现，最后的结果 data是等于1，并不是我们想象的等于2。

demo见：/Users/lyf/Workspace/www/blog-demo/thread-demo/src/main/java/unsafe/Test3.java

但是没有运行出来想要的效果。

### 22、你知道Java内存模型中的原子性、有序性、可见性是什么吗？

Java 内存模型 -》原子性、可见性、有序性 -》volatile -》 happens-before / 内存屏障

#### 可见性

#### 原子性

比如线程1在执行加的操作时（read、load、use、assign、store、write），那么线程2是不允许做加操作的。

只有在线程1把值写回到主内存后，线程2才能开始进行操作。

**这个就叫 有原子性**。

`什么叫有原子性？`

比如：data++这个操作，必须是独立运行的，没有人影响我的，一定是我自己执行成功之后，别人才能来进行下一次的 data++ 的执行。

#### 有序性

```txt
// 全局变量
flag = false;

// 线程1：
// 准备资源
prepare();
flag = true;

// 线程2：
while(!flag) {
	Thread.sleep(1000);
}
// 基于准备好的资源进行操作
execute();
```

所谓的有序性，就是指 你写的代码是这个样子，但是在编译的时候，编译器和指令器编译的时候，可能会为了提高代码执行效率，会对代码指令进行重新排序。比如，有可能会把 flag=true 排到了前边，就会导致 while 条件直接跳过了，资源还没有准备好呢，就进行操作了。=》导致整个代码逻辑就出问题了。

如果说具备有序性，也就是说不会发生指令重排。

### 23、能聊聊volatile关键字的原理吗？

volatile 是用来解决可见性、有序性的，在有些罕见的条件下，可以有限的保证原子性，他主要不是用来保证原子性的。

给 data 变量加上 volatile 关键字后，当data被更新后，数值 write 到主内存后，同时会将线程2里的 工作内存里的 data 缓存设置为失效，这样的话，就会强制从主内存重新 read 数据，也就拿到了最新的 data = 1。

<img src="1.assets/image-20220411165351189.png" alt="image-20220411165351189" style="zoom:50%;" />

比较适合的场景，对于多个线程，有的线程要更新这个变量，有的线程要读这个变量。使用volatile来保证可见性，一个线程更新后，另一个线程立马可以读到最新的值。

### 24、你知道指令重排以及happens-before原则是什么吗？

编译器、指令器可能对代码重排序。但是怎么能保证不乱排呢？这就是 happens-before原则。

只要符合happens-before 原则，那么就不能胡乱重排。

- 程序次序规则；
- 锁定规则；
- volatile变量规则；
- 传递规则；
- 线程启动规则；
- 线程中断规则。。。。。。

大概了解一下就行。

这些规则就指定了在一些特殊情况下，不允许指令重排。

### 25、volatile底层是如何基于内存屏障保证可见性和有序性的？

volatile + 可见性 -》volatile + 有序性（指令重排 + happens before）-》volatile + 原子性

那么直接告诉大家，`volatile 不能保证原子性`，虽然有些极端特殊的情况下有保证原子性的效果（比如 64位的long 数字进行操作，可以保证一定的原子性）。

`volatile 为什么不能保证原子性呢？`

- 比如线程a先得到了data的初始值为0，然后还没来得及修改就阻塞了；

- 这时线程b开始了，它也得到了data的值，即使data使用了关键字volatile修饰，但是由于主内存的变量值没有发送变化，所以线程b得到的值也是0，之后对其进行+1操作，然后将最新的值写入到缓存中，再刷入主存；
- 根据可见性原则，最新data值可以被其它线程都可见；
- 问题来了，线程已经读取到了data的值为0，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚了，线程a阻塞结束后，继续将data值加1，得到1，再将值写入缓存，再刷入主内存。
- 所以，`即使volatile可以保证可见性，也不能保证对它修饰的变量具有原子性`。

要想保证原子性，还是得使用 synchronized 或 lock 锁。

#### volatile 是怎么做到保证有序性的呢

加了volatile后，可以保证前后的一些代码不被指令重排，这个是如何做到的呢？

内存屏障是非常非常复杂的机制，这里只需要理解，加了volatile后：

LoadLoad 屏障

```
Load1:
int localVar = this.variable;

Load2:
int localVar = this.variable;
```

还有好多其他的屏障。

加入这些屏障后，就可以避免指令重排。

#### volatile是如何保证可见性的呢？

- 对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写会到主内存，同时因为有MESI 缓存一致性协议，所以各个CPU都会对总线进行嗅探自己本地的缓存是否被别人修改过。

- 如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上的线程在读取这个变量的时候，就会从主内存读取最新的数据了。

### 26、说说你对Spring的 IOC 机制的理解可以吗？

<img src="1.assets/image-20220411182934766.png" alt="image-20220411182934766" style="zoom:50%;" />

主要就是干了两件事儿：

- 一是实例化bean；
- 二是有依赖关系的对象进行依赖注入

底层用的主要技术：

- 就是反射，通过反射去创建对象

最大的作用：

- 就是代码层面的编码完全解耦。如果要实现代码层面的组件切换变动，不用进行硬编码，直接修改修改配置就行了，避免重复测试，避免bug的产生。

### 27、说说你对Spring的AOP机制的理解可以吗？

核心思想其实就是把系统中的重复代码给抽到切面（动态代理类）里的跟被代理对象同样名字的方法里。

切面，定义一批类的一批方法，

然后对这一批类的这一批方法织入增强的代码。

一旦定义好了这些后，spring的aop机制就会帮我们处理了（生成代理对象，在代理对象的方法里加入增强逻辑，然后Controller里注入的是这个代理对象）。

没有aop的时候，你的各个类里边可能会有很多重复、通用的代码。

有了aop后，定义一个切面，把这些重复的代码都放到切面类里写一次，然后运行的时候会生成一个动态代理类，然后把你写入的这些增强代码给织入进去。 

看一下 demo，手动写一下。

### 28、了解过cglib动态代理吗？他跟jdk动态代理的区别是什么？

https://zhuanlan.zhihu.com/p/126503023

静态代理就是在程序运行之前，代理类字节码`.class`就已编译好了。

动态代理类与静态代理类最主要不同的是，`代理类的字节码不是在程序运行前生成的，而是在程序运行时在虚拟机中程序自动创建的`。

### 29、额外加餐：能说说Spring中的Bean是线程安全的吗？

tomcat 会有专门的线程去监听指定的端口有没有请求过来，不同的请求会分发给不同的线程去处理。

要把这个问题给解释清楚，不要上来直接说是 线程安全，或者直接说是线程不安全的。从以下三个方面来解释：

1. 所有spring bean 是很有可能被多线程并发访问的同一个bean实例里的变量，比如存放一些非线程安全的变量。由于spring bean默认是singleton，单实例的，因此是线程不安全的。

类似这样：

```java
public class MyServiceImpl implements MyService {
	private int data;
  public void doService() {
    data++;
    ......
  }
} 
```

对实例变量 data 执行 加操作，这个时候就有可能会出现线程不安全的问题。

2. 如果你的单例bean里存放的是线程安全的实例变量，比如ConcurrentHashMap 类似的线程安全的数据结构的话，多线程并发访问的时候，其实也是安全的。

如果你的代码都是这样：

```java
public class MyServiceImpl implements MyService {
  public void doService() {
    // 访问数据库
  }
} 
```

3. 如果你的代理里没有在组件里边放一些状态而言的变量，都是访问数据库的一些操作，那么即使都是线程不安全，其实也没有关系，无非是会有多个线程并发的去访问数据库。

### 30、Spring的事务实现原理是什么？能聊聊你对事务传播机制的理解吗？

#### 事务的实现原理

 使用@Transactional 注解开启事务后，spring会使用aop的思想，拦截你的方法，对你的这个方法在执行之前，先去开启事务，执行完毕之后，根据你方法是否报错，来决定回滚还是提交事务。

#### 事务的传播机制

##### Propagation.REQUIRED

默认的传播级别是：Propagation.REQUIRED。多个方法调用，大家都加入到一个事务里去。

```java
@Transactional
public void methodA() {
   methodB();
   // do something
}

@Transactional
public void methodB() {
   // do something
}
```

大概类似于这样的效果：

```txt
// 开启事务
// 执行方法A的代码，接着执行方法B的代码
// 提交或者回滚事务
```



##### Propagation.SUPPORTS

**比较少用**

支持当前事务，如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```

比如 methodA() 方法调用 methodB()，methodB()方法的代码会加入事务；如果直接调用methodB()方法，则不会开启事务。

##### Propagation.MANDATORY

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```

比如 methodA() 方法调用 methodB()，methodB()方法的代码会加入事务；如果直接调用methodB()方法，则会报错。必须得先调用开启事务的方法，通过这个方法再来调用 methodB() 方法。

##### Propagation.NEW

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```



<img src="1.assets/image-20220412085007700.png" alt="image-20220412085007700" style="zoom:50%;" />

在  methodA() 方法调用 methodB() 的时候， methodB() 方法会开启一个新事务。两个事务互不影响。

### 31、额外加餐：能画一张图说说Spring Boot的核心架构吗？

SpringBoot程序通过执行main方法启动后 ：

```txt
=》 会启动内嵌的tomcat服务器 

=》把 Spring MVC的核心的原始组件比如 Servlet、Filter 给注册到 Tomcat 上去，Spring MVC 会接收所有的请求 =》同时也必然会启动 Spring 容器，扫描所有的代码，根据注解去实例化bean 实例 

=》tomcat 会监听指定的端口号，当有多个请求过来的时候，会有多个线程并发的处理请求 

=》多个线程会并发调用 Spring MVC 代码 

=》并发调用我们写的 Controller 代码 、Service、dao 代码。
```



Spring Boot 比较核心的是：

**做了很多自动装配的事儿。**

比如说：你要整合mybatis，

1. Spring Boot 会自动把 Mybatis的核心组件给 装配好 （自动完成bean的装配和定义）；

2. =》 因为 MyDAOImpl 这个bean 会需要使用到 这些核心组件bean，SpringBoot 就会自动把这些核心组件bean给注入到 MyDAOImpl 里去；
3. =》你的 Service 会应用 MyDAOImpl，然后 MyDAOImpl 就会调用 Mybatis的核心组件 =》调用数据库，执行SQL语句

#### 总结

- 没有SpringBoot的时候，我们得自己去写好代码，自己去部署tomcat，为了使用 Mybatis、Rabbitmq这些，我们需要配置各种各样的bean，自己去配置bean的依赖注入；

- 用Spring Boot后：
  - 它内嵌了tomcat 服务器，你直接执行main方法，就会给你启动一个tomcat；
  - 直接就把Spring mvc 这种所用到的bean都给注册完毕了；
  - 启动容器把所有bean实例化；
  - 自动把 Mybatis这些技术的核心bean自动进行装配，自动进行注入；
  - 后边有一连串的请求过来，比如要使用mybatis访问数据库，其实底层就会使用到Spring Boot 帮我们装配好的bean 去执行sql语句/访问redis啊等等。

### 32、额外加餐：能画一张图说说Spring的核心架构吗？

<img src="1.assets/image-20220412104346261.png" alt="image-20220412104346261" style="zoom:50%;" />

#### spring的生命周期

spring会管理我们的bean。

那么bean的生命周期是什么？

所谓的生命周期就是指 什么时候创建 -》什么时候使用 -》什么时候销毁

1. 使用bean；
2. 依赖注入
3. 处理Aware接口；
4. BeanPostProcessor的 before
5. InitializingBean 与 init-method
6. BeanPostProcessor的 after

到这一步，bean的整个创建和初始化已经完成。给你提供了接口和扩展点。

使用bean。当bean不再需要的时候，会经过清理阶段。

7. DisposableBean
8. destory-method

### 33、能说说Spring中都使用了哪些设计模式吗？

#### 工厂模式

对象创建的过程，封装在工厂类里的一个静态方法里了。

Spring IOC 核心的设计模式思想的体现，他就是一个大工厂，把所有的bean实例都放在了 spring 容器里（大工厂），如果你要使用bean，就找 spring 容器就可以了，你自己不用创建对象了。

#### 单例模式

spring默认来说，对每个bean都是单例类。确保你的一个类在运行期间只有一个实例对象，只有一个bean。

```java
public class DoubleCheckSingleton {
	private static volatile DoubleCheckSingleton instance;
  private DoubleCheckSingleton() {}
  public static DoubleCheckSingleton getInstance() {
    if (instance == null) {
      // 能够保证有多个线程过来的时候，只会有一个线程加锁成功,其它线程会卡在这里
      synchronized(DoubleCheckSingleton.class) {
        // 第一个线程进来，发现instance为空，就创建一个实例
        // 第二个线程进来后，如果不加这个if判断，就会再创建一次实例。
        if (instance == null) {
          instance = new DoubleCheckSingleton();
        }
      }
    }
    return instance;
  }
}
```

#### 代理模式

如果说你要对一些类的一些方法切入一些增强的代码，spring中就会创建代理对象，当你对那些目标对象访问时，会先经过代理对象，执行代理对象里的一些增强代码，然后再调用你的目标对象的方法。

在设计模式里，这就是一个代理模式的体现和运用。

### 34、额外加餐：能画一张图说说Spring Web MVC的核心架构吗？

对于Spring MVC，其实就是有一个 Servlet 注册到 tomcat 里去，然后tomcat收到请求后，通过线程把请求给 Spring MVC 的Servlet，然后进行一路调用，最后返回数据。

以前都是由 spring mvc 通过模板技术渲染页面，直接返回给浏览器了。

现在都是前后端分离，返回json数据给前端工程，由前端工程渲染页面，返回给浏览器。

### 35、额外加餐：能画一张图说说Spring Cloud的核心架构吗？

eureka、ribbon、feign、zuul、hystrix

ribbon + feign

ribbon 负载均衡，feign 构造http请求，进行rpc调用

### 36、JVM中有哪几块内存区域？Java 8之后对内存分代做了什么改进？

我们基于框架写一些代码，完事儿之后，就会把代码进行一个部署。一般来说是通过 tomcat、jetty 来部署java web系统。

tomcat 部署，tomcat自己就是基于java来开发的，我们启动的不是自己的系统，启动的是tomcat的jvm进程。

我们的系统代码只不过是放在tomcat的某个目录下面，tomcat会去加载我们的代码到jvm里去。

tomcat去负责接收请求，执行我们写好的代码。

### 36-43 是关于jvm的

### 42、你在实际项目中是否做过JVM GC优化，怎么做的？

这个可以借助数屏工程 data-board的，来稍微包装一下。

试着在本地单机部署，然后压测一下，比如单机 500 并发请求，去观察jvm的运行情况，这个时候会不会存在频繁GC的问题，你就去调优一下。就可以基于这个压测的例子去说了。



### 44-46_你能聊聊TCP/IP四层网络模型吗？OSI七层网络模型也说一下！

经常用的是四层：数据链路层、网络层、传输层、应用层。

#### 物理层

可以理解为 网线、海底电缆，统一属于网络的物理层。然后传递0/1电路信号

#### 数据链路层

物理层给两个电脑连接起来了，还传输最底层的0和1电路信号，肯定不行啊，你得定义清楚哪些0和1分为一组。

这些信号啥意思，这样才能进行通信。

一组电路信号是一个数据包，叫一个帧，每个帧包含两部分，包含头和数据。

子网内的电脑是广播出去的，那怎么知道哪些电脑是在一个子网里呢？这就得靠网络层了，这里有一套IP地址，IP地址就可以让我们区分哪些电脑是一个子网的。

#### 网络层

网络层里有IP协议，IP协议定义的地址就叫IP地址。

#### 传输层

tcp 协议。

传输层的tcp协议，仅仅只是规定了一套基于端口的点对点的通信协议，包括如何建立连接、如何发送和读取消息，但是实际上，如果你要基于tcp协议进行开发，一般就是使用socket，java socket网络编程。

#### 应用层

通过tcp的传输层可以传输数据，但是人家收到数据之后，怎么来处理？

 应用层就是拿到数据后，怎么来处理数据？=》Http协议。

### 47、浏览器请求www.baidu.com的全过程大概是怎么样的？（上）

http协议分为几个部分：

​    <img src="1.assets/image-20220412152643762.png" alt="image-20220412152643762" style="zoom:80%;" />  

1、浏览器请求一个地址，会先按照应用层的http协议，封装一个应用层数据包，数据包里就放了http请求报文；

2、接着就到了传输层，传输层是 tcp 协议；

3、网络层，走的是Ip协议

4、数据链路层，这块走以太网协议

​      以太网的数据包有个限制，每个数据包最多只能放1500个字节。如果Ip数据包大于1500个字节，那么需要切成几个包。

<img src="1.assets/image-20220412153414541.png" alt="image-20220412153414541" style="zoom:50%;" />

### 49、画一下TCP三次握手流程图？为啥是三次而不是二次或者四次呢？

### 50、聊聊HTTP协议的工作原理！



http的关键就是让你聊聊http请求和http响应的规范。

#### 请求的报文

请求行、请求头、请求方法、请求正文。

```txt
POST http://user/api/v1/list Http 1.1  // 请求行
HOST: www.baidu.com
User-Agent：Mozilla/5.0 （windows NT 6.1；rv：15.0）Gecko/20100101 Firefox/15.0        //空白行，代表请求头结束
Username=admin&password=admin       //请求正文
```



#### 响应的报文

状态行、响应头、响应正文。

```txt
HTTP/1.1 200 OK  // 响应行
Date: Sun, 15 Nov 2015 11:02:04 GMT    //响应头
Context-Type: application/javascript
Context-Length:2605
Context-Encoding:gzip
Expires: Fri, 13 Jun 2025 09:54:00 GMT
					      //空白行，代表响应头结束
<html>
<head><title>Index.html</title></head>
</html>
```

#### http的工作原理

就是按照http协议封装了http请求，把http请求数据包封装在tcp数据包里，再封装包网络数据包里，再封装到以太网数据包里，如果包过大，可能会拆成几个包，然后走以太网协议+交换机 -》 广播 -》网关-》 多个网关 -》目标的机器 -》一层一层拆包，取出对应http报文 -》做出解析，传递给tomcat -》spring mvc -》http响应。

最最底层数据如何传输走的是物理层，网线，光缆传输，所有数据都是0/1电路信号。

#### http1.0

早期（2000年之前）因为网站都是文字，没有什么图片呀，css呀，所以默认是短连接，其实走的就是底层的tcp连接。

发一次请求，响应，就断开了。

2000年之后，特别是2010年，网站发展非常迅猛，一个网页包含大量的突破，css，js。

如果还是基于http1.0的话，那显然是不行的。

比如需要建立30次 tcp连接，释放30次tcp连接。

其实最慢的不是说发送请求和获取响应，打开和释放连接，其实是很重的过程。

#### http1.1

http1.1默认是支持长连接的。

浏览器第一次去请求一个网站的页面的时候，就会打开一个tcp连接，接着就在一段时间内就都不关闭了，然后接下来这个网页加载css、js、图片等大量的请求全部走同一个tcp连接了。

等这些请求都完毕了，然后才回去释放那个tcp连接。大幅提升复杂网页的打开速度、性能。

#### http2.0

还没有推广开。支持多路复用，基于一个tcp连接并行发送多个请求及接收响应，解决了http1.1对同一时间同一个域名的请求有限制的问题。

### 51、聊聊HTTPS的工作原理？为啥用HTTPS就可以加密通信？

有点绕，跳过了。

### 52、聊聊http的长连接的工作原理到底是啥？

http其实没有长连接、短连接一说。

指的是http 1.0的底层tcp是短连接；http1.1的底层tcp是长连接。

### 53、MySQL、MyISAM和InnoDB存储引擎的区别是啥？（上）

### 54、MySQL、MyISAM和InnoDB存储引擎的区别是啥？（下）

- MyIsam

  适合使用的场景是：查询多，插入或更新少的场景，比如基于大数据的产出的数据报表系统。

- innodb
  支持事务。业务系统，支持增删改查的场景。支持分库分表、读写分离、主备切换，全部都可以基于innodb来玩儿。


### 55、聊聊MySQL的索引实现原理？各种索引你们平时都怎么用的？（上）

#### 索引的数据结构

mysql索引是一颗b+树。

要了解b+树，先来看看b-树：

<img src="1.assets/image-20220412214056860.png" alt="image-20220412214056860" style="zoom:50%;" />

b+树跟b-树不太一样的地方在于：

<img src="1.assets/image-20220412214352499.png" alt="image-20220412214352499" style="zoom:50%;" />

最大的区别：

非叶子节点只存储key，不存储data。

#### myisam存储引擎的索引实现

在myisam存储引擎的索引中，每个叶子节点的data存放的是数据行的物理地址，比如 0x07 之类的东西，然后我们可以画一个数据表出来，一行一行的，每行对应一个物理地址。

索引文件：

<img src="1.assets/Mysql索引-B+树.png" alt="Mysql索引-B+树" style="zoom:80%;" />

id=15，data：0x07，0a89，这样的物理地址

数据文件会单独放一个文件：

物理地址    id  name  age

0x07          15   张三    25

0a89          22  李四     34

然后执行：

```
select * from table where id = 15
```

时，其实会先由 id =15 找到 物理地址 0x07，再由 0x07 去数据文件里里找到对应的那一行数据。=》 15 张三 25

#### innodb存储引擎索引

强制要求必须要有主键。默认内置的就会根据主键建立一个索引，叫做聚簇索引。

innodb 的数据文件，本身也是个索引文件。这个索引就是默认根据主键建立的，叫做聚簇索引。

id=15， data： 15 张三 25 （完整的一行数据）

假如 name 字段建了索引，那么此时查找 name：

```mysql
select * from table where name = "张三"
```

先到name的索引里去找，找到 "张三" 对应的叶子节点，叶子节点的data 就是那一行的主键 id = 15，

然后再到数据文件的聚簇索引里根据 id = 15 去定位出来这一行完整的数据。

#### 索引使用规则

