面试突击的定位

面试突击第一季：

redis连环炮、mq连环炮、网络连环炮、JDK集合连环炮、jvm连环炮、spring源码连环炮、tomcat连环炮、linux连环炮、系统设计连环炮、生产实践连环炮

面试突击第二季：

针对分布式架构这个专题讲，带一点点的小深度。

面试突击第三季：

对于每一个小专题（偏基础），都会挑选几个高频的问题出来进行讲解。

## HashMap

### 你知道HaspMap底层的数据结构是什么吗

底层最核心的数据结构就是 数组。

往里边put数据的时候，会根据key算出来一个hash值，根据hash值与Map的长度进行取模（比如长度是16，取模后的值肯定是在0到16之间），然后就会定位到数组的一个元素里去。

### 你知道HashMap是如何解决hash碰撞的吗

**Java中的hashCode方法就是根据一定的规则，将与对象相关的信息（比如对象的存储地址、对象的字段等）映射成一个数值，这个数值称为散列值。**

最最简单的理解：

<img src="1.assets/image-20220408180459135.png" alt="image-20220408180459135" style="zoom:50%;" />

异或，两个不一样值就为1。hash算法，右移16位：

<img src="1.assets/image-20220408184331351.png" alt="image-20220408184331351" style="zoom:50%;" />

右移16位，高16位 与 低16位，进行异或。

**意义在哪**

hash算法优化：

对每个hash值，在他的低16位中，让高低16位都进行了异或，让他的低16位同时保持了高16位的特征，尽量避免一些hash值后续出现冲突，进入数组的同一个位置。

经过这个算法，尽量让高16位和低16位，都参与到了运算，尽量避免后边产生hash冲突。

寻址算法优化：

 (n - 1) & hash 的性能会比较高，就跟数学公式那样记着就行了。用与运算替代取模，提升性能。

##### hash冲突

多个key，他们计算出来的hash值，与 n-1 与运算之后，发现定位出来的数组还是同一个位置，这就是hash碰撞、hash冲突了。

这个时候会在这个位置挂一个链表，这个链表里放入多个元素，让多个key-value对同时放在数组的同一个位置里。

get的时候如果发现这个位置挂的是一个链表，那么此时就遍历该链表，从里边找到自己想要的那个key-value对即可。

假设你的链表很长，可能会导致遍历链表性能会比较差，O(n)。

`做了什么优化呢`：

如果链表的长度达到了一定的长度后，就会将链表转换为红黑树，遍历一颗红黑树找一个元素，此时是 O(logn)，性能会比链表高。

### 说说HashMap是如何进行扩容的

hashmap底层是一个数组，当这个数组满了之后，他会自动进行扩容，变成一个更大的数组，让你在里面可以放更多的元素。

默认就是2倍扩容，扩容之后要进行rehash，给元素重新分配位置。

比如原来数组的长度是16，数组的长度扩容之后就变为32，会重新对每个hash值进行寻址，也就是用每个hash值跟新数组的 length-1 进行与运算。

举例：

```
n-1：  0000 0000 0000 0000 0000 0000 0001 1111
hash1：1111 1111 1111 1111 0000 1111 0000 0101
&结果： 0000 0000 0000 0000 0000 0000 0000 0101 = 5 (index=5的位置)
```



```
n-1：  0000 0000 0000 0000 0000 0000 0001 1111
hash1：1111 1111 1111 1111 0000 1111 0001 0101
&结果： 0000 0000 0000 0000 0000 0000 0001 0101 = 21 (index=21的位置)
```

判断二进制结果中是否多出1个bit 的1，如果没多，那就是原来的index，如果多了出来，那么就是index + oldCap（原来数组的长度），通过这个方式，就避免了refresh的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高。

## BAT面试官为什么都喜欢问并发编程的问题

syncronized实现原理、CAS无锁化的原理、AQS是什么、Lock锁、ConcurrentHashMap分段加锁的原理、线程池的原理、java内存模型、volatile、对java并发包有什么了解。

### 12、说说synchronized关键字的底层原理是什么？

可以对对象加锁，也可以对类加锁。

底层原理是跟JVM指令和monitor对象有关。

<img src="1.assets/image-20220409232711892.png" alt="image-20220409232711892" style="zoom:50%;" />

### 13、能聊聊你对CAS的理解以及其底层实现原理可以吗？

cas是原子的，底层会对应着硬件级别的一些类似锁的机制（`使用 cpu 硬件提供的 lock 信号保证其原子性`）。

一次cas只能有一个线程执行成功。

比如线程1执行cas的时候发现旧值是0跟最初读到的值是一样的，说明此时没有别的线程修改过，则累加1。

线程2在执行cas的时候，则发现已经变为1，与最初读到的值不一样了，cas就失败了。于是会重新读取当前值，发现是1，再次尝试累加为2，这个时候已经没有其他线程在执行CAS操作了，会发现旧值跟最初读到的值是一样的，则累加为2成功。

CAS在底层的硬件级别给你保证 一定是原子性的，同一时间只有一个线程可以执行cas，先比较再设置。其他线程的CAS同时间执行此时会失败。

### 14、ConcurrentHashMap实现线程安全的底层原理到底是什么？

有多个线程要同时修改一个数据的时候，可能会有线程安全的问题，这个时候可以使用 synchronized 进行加锁 或 CAS 去进行安全的累加，去实现多线程场景下的安全的更新一个数据的效果。

JDK并发包里推出了一个 ConcurrentHashMap，默认实现了线程安全性。

#### JDK1.7及JDK1.7之前

JDK1.7及JDK1.7之前，采用的是分段加锁。因为HashMap的底层还是数组，将一个数组分成多个小的数组，每个小数组都对应一个锁，实现分段加锁。

put多个元素的时候，如果put的元素是属于不同的数组的，则互不影响。

#### JDK1.8以及以后

又变成了只有一个数组。然后数组里的每一个元素进行put操作的时候，都是有一个不同的锁。

如果两个线程都是要对同一个位置进行put操作，就采取CAS的策略。

如果多个线程对不同位置进行操作这时是没有关系的，如果是对同一个位置进行。如果CAS执行失败了，就表明比如数组[5]这个位置，刚刚已经有别的线程往这个位置放入元素了，这个时候就需要在这个位置基于链表+红黑树进行处理。

会采取类似 synchronized(数组[5])这种方式，对数组[5]这个对象进行加锁，然后基于链表或红黑树在这个位置插入自己的数据。

你想想，如果不采用这种方式，而是直接对整个数组加锁，这样就相当于串行，效率会比较低的。

所以JDK1.8以后，就是这种方式：

`如果多个线程对不同位置的元素操作，此时大家是可以并发执行的；如果是对同一个位置的元素进行操作，才会加锁串行化处理。`

### 15、你对JDK中的AQS理解吗？AQS的实现原理是什么？

abstract queue synchronizer，抽象队列同步器

```java
ReentrantLock lock = new ReentrantLock();

// 多个线程过来都尝试对同一个lock进行加锁

lock.lock();

// 代码

lock.unlock;
```



ReentrantLock 底层有个核心的组件就是 AQS：

<img src="1.assets/image-20220411082006002.png" alt="image-20220411082006002" style="zoom:50%;" />



### 16、说说线程池底层工作原理可以吗？

### 17、那你再说说线程池的核心配置参数都是干什么的？平时我们应该怎么用？

<img src="1.assets/image-20220411084408505.png" alt="image-20220411084408505" style="zoom:50%;" />



newFixedThreadPool 举例，这些参数分别是干什么用的？

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

- corePoolSize：核心线程数量，比如设置为 3 个；
- maximumPoolSize：比如设置为 200。当队列中一下子来了很多任务，corePoolSize 这3个线程也还在处理任务，没有空闲的，这时就会再创建新的线程，能创建的最大数量就是这个maximumPoolSize；
- keepAliveTime：比如设置为 60s。当队列中的任务都被处理完毕之后，再等 60s，如果还没有新的任务到来，则会销毁 额外创建的线程；
- BlockingQueue<Runnable> workQueue：设置的队列

如果额外线程也满了，队列也满了，此时还有任务要进来，只能reject 掉，他有几种 reject 策略，可以传入 RejectedExecutionHandler

平时怎么用？

1. 可以让队列设置为无界队列，这样队列就不会满，就不用创建额外线程；
2. 也可以使用有界队列，然后 maximumPoolSize设置为 Integer.MAX_VALUE。

### 18、如果在线程中使用无界阻塞队列会发生什么问题？

比如，假如线程里边会调用远程的服务。那么在远程服务异常的情况下，使用无界阻塞队列，会导致内存飙升。

调用超时，假如有新的任务不断的进来，则队列会变得越来越大，此时会导致内存突然飙升起来，而且还可能导致系统 OOM，内存溢出。

### 19、你知道如果线程池的队列满了之后，会发生什么事情吗？

如果你的线程池这样设置：

- corePoolSize：10；
- maximumPoolSize： Integer.MAX_VALUE；
- ArrayBlockingQueue(200)；

有界队列，可以避免内存溢出。但是在队列满了之后，你要给人家讲清楚后边的原理。

**这时会创建很多额外线程。假设有很多任务，corePoolSize 也满了，这时就会无限制的创建额外线程。**

但是每个线程都有 栈内存，无限制的创建线程 也会导致内存资源耗尽，系统也会崩溃掉。

即使内存没有崩溃，但创建过多的线程也有可能会导致你的cpu负载特别的高。

如果此时将 maximumPoolSize 调小一点，比如调为 200，那么会导致有很多的任务直接就走 拒绝策略被 拒绝掉了。

面试官这样问，其实就是想了解你对线程池的底层原理是否了解。

那么该怎么创建线程池呢？具体得看你的业务系统，比如会不会有瞬间来多个任务，或者每个任务处理时间是否需要很久。

**也可以自定义一个 reject 策略。如果线程池无法创建更多任务了，此时可以把后续的任务信息持久化到磁盘里去，然后后台可以专门启动一个线程，等待你的线程池工作负载降低了，他可以慢慢的从磁盘里读取之前持久化的任务，重新提交到线程池里去。**

### 20、如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？

会必然导致线程池里积压的任务 实际上都会丢失的。

**那怎么解决这个问题呢？**

1. 如果你要提交任务到线程池里去，那么在提交任务到线程池里去之前，麻烦你现在数据库里插入这个任务信息，同时设置一个状态字段：未提交、已提交、提交成功。

2. 然后，搞一个后台线程，扫描数据库里 未提交和已提交的任务信息，重新提交到线程池里去。

3. 这个时候，如果机器突然宕机，然后系统重启后，后台线程处理这个逻辑就行了。

### 21、谈谈你对Java内存模型的理解可以吗？

<img src="1.assets/image-20220411140652594.png" alt="image-20220411140652594" style="zoom:50%;" />

多个线程同时操作一个内存中的变量，需要经过 read、load、use、aggign、store、write 六个指令。

Java内存模型，多线程并发时的一个工作流程原理。

我们会发现，最后的结果 data是等于1，并不是我们想象的等于2。

demo见：/Users/lyf/Workspace/www/blog-demo/thread-demo/src/main/java/unsafe/Test3.java

但是没有运行出来想要的效果。

### 22、你知道Java内存模型中的原子性、有序性、可见性是什么吗？

Java 内存模型 -》原子性、可见性、有序性 -》volatile -》 happens-before / 内存屏障

#### 可见性

#### 原子性

比如线程1在执行加的操作时（read、load、use、assign、store、write），那么线程2是不允许做加操作的。

只有在线程1把值写回到主内存后，线程2才能开始进行操作。

**这个就叫 有原子性**。

`什么叫有原子性？`

比如：data++这个操作，必须是独立运行的，没有人影响我的，一定是我自己执行成功之后，别人才能来进行下一次的 data++ 的执行。

#### 有序性

```txt
// 全局变量
flag = false;

// 线程1：
// 准备资源
prepare();
flag = true;

// 线程2：
while(!flag) {
	Thread.sleep(1000);
}
// 基于准备好的资源进行操作
execute();
```

所谓的有序性，就是指 你写的代码是这个样子，但是在编译的时候，编译器和指令器编译的时候，可能会为了提高代码执行效率，会对代码指令进行重新排序。比如，有可能会把 flag=true 排到了前边，就会导致 while 条件直接跳过了，资源还没有准备好呢，就进行操作了。=》导致整个代码逻辑就出问题了。

如果说具备有序性，也就是说不会发生指令重排。

### 23、能聊聊volatile关键字的原理吗？

volatile 是用来解决可见性、有序性的，在有些罕见的条件下，可以有限的保证原子性，他主要不是用来保证原子性的。

给 data 变量加上 volatile 关键字后，当data被更新后，数值 write 到主内存后，同时会将线程2里的 工作内存里的 data 缓存设置为失效，这样的话，就会强制从主内存重新 read 数据，也就拿到了最新的 data = 1。

<img src="1.assets/image-20220411165351189.png" alt="image-20220411165351189" style="zoom:50%;" />

比较适合的场景，对于多个线程，有的线程要更新这个变量，有的线程要读这个变量。使用volatile来保证可见性，一个线程更新后，另一个线程立马可以读到最新的值。

### 24、你知道指令重排以及happens-before原则是什么吗？

编译器、指令器可能对代码重排序。但是怎么能保证不乱排呢？这就是 happens-before原则。

只要符合happens-before 原则，那么就不能胡乱重排。

- 程序次序规则；
- 锁定规则；
- volatile变量规则；
- 传递规则；
- 线程启动规则；
- 线程中断规则。。。。。。

大概了解一下就行。

这些规则就指定了在一些特殊情况下，不允许指令重排。

### 25、volatile底层是如何基于内存屏障保证可见性和有序性的？

volatile + 可见性 -》volatile + 有序性（指令重排 + happens before）-》volatile + 原子性

那么直接告诉大家，`volatile 不能保证原子性`，虽然有些极端特殊的情况下有保证原子性的效果（比如 64位的long 数字进行操作，可以保证一定的原子性）。

`volatile 为什么不能保证原子性呢？`

- 比如线程a先得到了data的初始值为0，然后还没来得及修改就阻塞了；

- 这时线程b开始了，它也得到了data的值，即使data使用了关键字volatile修饰，但是由于主内存的变量值没有发送变化，所以线程b得到的值也是0，之后对其进行+1操作，然后将最新的值写入到缓存中，再刷入主存；
- 根据可见性原则，最新data值可以被其它线程都可见；
- 问题来了，线程已经读取到了data的值为0，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚了，线程a阻塞结束后，继续将data值加1，得到1，再将值写入缓存，再刷入主内存。
- 所以，`即使volatile可以保证可见性，也不能保证对它修饰的变量具有原子性`。

要想保证原子性，还是得使用 synchronized 或 lock 锁。

#### volatile 是怎么做到保证有序性的呢

加了volatile后，可以保证前后的一些代码不被指令重排，这个是如何做到的呢？

内存屏障是非常非常复杂的机制，这里只需要理解，加了volatile后：

LoadLoad 屏障

```
Load1:
int localVar = this.variable;

Load2:
int localVar = this.variable;
```

还有好多其他的屏障。

加入这些屏障后，就可以避免指令重排。

#### volatile是如何保证可见性的呢？

- 对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写会到主内存，同时因为有MESI 缓存一致性协议，所以各个CPU都会对总线进行嗅探自己本地的缓存是否被别人修改过。

- 如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上的线程在读取这个变量的时候，就会从主内存读取最新的数据了。

### 26、说说你对Spring的 IOC 机制的理解可以吗？

<img src="1.assets/image-20220411182934766.png" alt="image-20220411182934766" style="zoom:50%;" />

主要就是干了两件事儿：

- 一是实例化bean；
- 二是有依赖关系的对象进行依赖注入

底层用的主要技术：

- 就是反射，通过反射去创建对象

最大的作用：

- 就是代码层面的编码完全解耦。如果要实现代码层面的组件切换变动，不用进行硬编码，直接修改修改配置就行了，避免重复测试，避免bug的产生。

### 27、说说你对Spring的AOP机制的理解可以吗？

核心思想其实就是把系统中的重复代码给抽到切面（动态代理类）里的跟被代理对象同样名字的方法里。

切面，定义一批类的一批方法，

然后对这一批类的这一批方法织入增强的代码。

一旦定义好了这些后，spring的aop机制就会帮我们处理了（生成代理对象，在代理对象的方法里加入增强逻辑，然后Controller里注入的是这个代理对象）。

没有aop的时候，你的各个类里边可能会有很多重复、通用的代码。

有了aop后，定义一个切面，把这些重复的代码都放到切面类里写一次，然后运行的时候会生成一个动态代理类，然后把你写入的这些增强代码给织入进去。 

看一下 demo，手动写一下。

### 28、了解过cglib动态代理吗？他跟jdk动态代理的区别是什么？

https://zhuanlan.zhihu.com/p/126503023

静态代理就是在程序运行之前，代理类字节码`.class`就已编译好了。

动态代理类与静态代理类最主要不同的是，`代理类的字节码不是在程序运行前生成的，而是在程序运行时在虚拟机中程序自动创建的`。

### 29、额外加餐：能说说Spring中的Bean是线程安全的吗？

tomcat 会有专门的线程去监听指定的端口有没有请求过来，不同的请求会分发给不同的线程去处理。

要把这个问题给解释清楚，不要上来直接说是 线程安全，或者直接说是线程不安全的。从以下三个方面来解释：

1. 所有spring bean 是很有可能被多线程并发访问的同一个bean实例里的变量，比如存放一些非线程安全的变量。由于spring bean默认是singleton，单实例的，因此是线程不安全的。

类似这样：

```java
public class MyServiceImpl implements MyService {
	private int data;
  public void doService() {
    data++;
    ......
  }
} 
```

对实例变量 data 执行 加操作，这个时候就有可能会出现线程不安全的问题。

2. 如果你的单例bean里存放的是线程安全的实例变量，比如ConcurrentHashMap 类似的线程安全的数据结构的话，多线程并发访问的时候，其实也是安全的。

如果你的代码都是这样：

```java
public class MyServiceImpl implements MyService {
  public void doService() {
    // 访问数据库
  }
} 
```

3. 如果你的代理里没有在组件里边放一些状态而言的变量，都是访问数据库的一些操作，那么即使都是线程不安全，其实也没有关系，无非是会有多个线程并发的去访问数据库。

### 30、Spring的事务实现原理是什么？能聊聊你对事务传播机制的理解吗？

#### 事务的实现原理

 使用@Transactional 注解开启事务后，spring会使用aop的思想，拦截你的方法，对你的这个方法在执行之前，先去开启事务，执行完毕之后，根据你方法是否报错，来决定回滚还是提交事务。

#### 事务的传播机制

##### Propagation.REQUIRED

默认的传播级别是：Propagation.REQUIRED。多个方法调用，大家都加入到一个事务里去。

```java
@Transactional
public void methodA() {
   methodB();
   // do something
}

@Transactional
public void methodB() {
   // do something
}
```

大概类似于这样的效果：

```txt
// 开启事务
// 执行方法A的代码，接着执行方法B的代码
// 提交或者回滚事务
```



##### Propagation.SUPPORTS

**比较少用**

支持当前事务，如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```

比如 methodA() 方法调用 methodB()，methodB()方法的代码会加入事务；如果直接调用methodB()方法，则不会开启事务。

##### Propagation.MANDATORY

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```

比如 methodA() 方法调用 methodB()，methodB()方法的代码会加入事务；如果直接调用methodB()方法，则会报错。必须得先调用开启事务的方法，通过这个方法再来调用 methodB() 方法。

##### Propagation.MANDATORY

```java
@Transactional(propagation=Propagation.REQUIRED)
public void methodA() {
   methodB();
   // do something
}

@Transactional(propagation=Propagation.SUPPORTS)
public void methodB() {
   // do something
}
```



<img src="1.assets/image-20220412085007700.png" alt="image-20220412085007700" style="zoom:50%;" />

在  methodA() 方法调用 methodB() 的时候， methodB() 方法会开启一个新事务。两个事务互不影响。



